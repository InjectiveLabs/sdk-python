# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: injective/exchange/v1beta1/exchange.proto, injective/exchange/v1beta1/tx.proto, injective/exchange/v1beta1/genesis.proto, injective/exchange/v1beta1/query.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List, Optional

import betterproto
import grpclib

from .cosmos.base import v1beta1
from .injective.oracle import v1beta1


class MarketStatus(betterproto.Enum):
    Unspecified = 0
    Active = 1
    Paused = 2
    Suspended = 3
    Demolished = 4
    Expired = 5


class OrderType(betterproto.Enum):
    UNSPECIFIED = 0
    BUY = 1
    SELL = 2
    STOP_BUY = 3
    STOP_SELL = 4
    TAKE_BUY = 5
    TAKE_SELL = 6


class ExecutionType(betterproto.Enum):
    UnspecifiedExecutionType = 0
    Market = 1
    LimitFill = 2
    LimitMatchRestingOrder = 3
    LimitMatchNewOrder = 4


class ExchangeType(betterproto.Enum):
    EXCHANGE_UNSPECIFIED = 0
    SPOT = 1
    DERIVATIVES = 2


@dataclass
class Params(betterproto.Message):
    # spot_market_instant_listing_fee defines the expedited fee in INJ required
    # to create a spot market by bypassing governance
    spot_market_instant_listing_fee: v1beta1.Coin = betterproto.message_field(1)
    # derivative_market_instant_listing_fee defines the expedited fee in INJ
    # required to create a derivative market by bypassing governance
    derivative_market_instant_listing_fee: v1beta1.Coin = betterproto.message_field(2)
    # default_spot_maker_fee defines the default exchange trade fee for makers on
    # a spot market
    default_spot_maker_fee_rate: str = betterproto.string_field(3)
    # default_spot_taker_fee_rate defines the default exchange trade fee rate for
    # takers on a new spot market
    default_spot_taker_fee_rate: str = betterproto.string_field(4)
    # default_derivative_maker_fee defines the default exchange trade fee for
    # makers on a new derivative market
    default_derivative_maker_fee_rate: str = betterproto.string_field(5)
    # default_derivative_taker_fee defines the default exchange trade fee for
    # takers on a new derivative market
    default_derivative_taker_fee_rate: str = betterproto.string_field(6)
    # default_initial_margin_ratio defines the default initial margin ratio on a
    # new derivative market
    default_initial_margin_ratio: str = betterproto.string_field(7)
    # default_maintenance_margin_ratio defines the default maintenance margin
    # ratio on a new derivative market
    default_maintenance_margin_ratio: str = betterproto.string_field(8)
    # default_funding_interval defines the default funding interval on a
    # derivative market
    default_funding_interval: int = betterproto.int64_field(9)
    # funding_multiple defines the timestamp multiple that the funding timestamp
    # should be a multiple of
    funding_multiple: int = betterproto.int64_field(10)
    # relayer_fee_share_rate defines the trade fee share percentage that goes to
    # relayers
    relayer_fee_share_rate: str = betterproto.string_field(11)
    # default_hourly_funding_rate_cap defines the default maximum absolute value
    # of the hourly funding rate
    default_hourly_funding_rate_cap: str = betterproto.string_field(12)
    # hourly_interest_rate defines the hourly interest rate
    default_hourly_interest_rate: str = betterproto.string_field(13)
    # max_derivative_order_side_count defines the maximum number of derivative
    # active orders a subaccount can have for a given orderbook side
    max_derivative_order_side_count: int = betterproto.uint32_field(14)


@dataclass
class DerivativeMarket(betterproto.Message):
    """
    An object describing a derivative market in the Injective Futures Protocol.
    """

    # Ticker for the derivative contract.
    ticker: str = betterproto.string_field(1)
    # Oracle base currency
    oracle_base: str = betterproto.string_field(2)
    # Oracle quote currency
    oracle_quote: str = betterproto.string_field(3)
    # Oracle type
    oracle_type: v1beta1.OracleType = betterproto.enum_field(4)
    # Scale factor for oracle prices.
    oracle_scale_factor: int = betterproto.uint32_field(5)
    # Address of the quote currency denomination for the derivative contract
    quote_denom: str = betterproto.string_field(6)
    # Unique market ID.
    market_id: str = betterproto.string_field(7)
    # initial_margin_ratio defines the initial margin ratio of a derivative
    # market
    initial_margin_ratio: str = betterproto.string_field(8)
    # maintenance_margin_ratio defines the maintenance margin ratio of a
    # derivative market
    maintenance_margin_ratio: str = betterproto.string_field(9)
    # maker_fee_rate defines the maker fee rate of a derivative market
    maker_fee_rate: str = betterproto.string_field(10)
    # taker_fee_rate defines the taker fee rate of a derivative market
    taker_fee_rate: str = betterproto.string_field(11)
    # relayer_fee_share_rate defines the percentage of the transaction fee shared
    # with the relayer in a derivative market
    relayer_fee_share_rate: str = betterproto.string_field(12)
    # true if the market is a perpetual market. false if the market is an expiry
    # futures market
    is_perpetual: bool = betterproto.bool_field(13)
    # Status of the market
    status: "MarketStatus" = betterproto.enum_field(14)
    # min_price_tick_size defines the minimum tick size that the price and margin
    # required for orders in the market
    min_price_tick_size: str = betterproto.string_field(15)
    # min_quantity_tick_size defines the minimum tick size of the quantity
    # required for orders in the market
    min_quantity_tick_size: str = betterproto.string_field(16)


@dataclass
class ExpiryFuturesMarketInfo(betterproto.Message):
    # market ID.
    market_id: str = betterproto.string_field(1)
    # expiration_timestamp defines the expiration time for a time expiry futures
    # market.
    expiration_timestamp: int = betterproto.int64_field(2)
    # expiration_twap_start_timestamp defines the start time of the TWAP
    # calculation window
    twap_start_timestamp: int = betterproto.int64_field(3)
    # expiration_twap_start_price_cumulative defines the cumulative price for the
    # start of the TWAP window
    expiration_twap_start_price_cumulative: str = betterproto.string_field(4)
    # settlement_price defines the settlement price for a time expiry futures
    # market.
    settlement_price: str = betterproto.string_field(5)


@dataclass
class PerpetualMarketInfo(betterproto.Message):
    # market ID.
    market_id: str = betterproto.string_field(1)
    # hourly_funding_rate_cap defines the maximum absolute value of the hourly
    # funding rate
    hourly_funding_rate_cap: str = betterproto.string_field(2)
    # hourly_interest_rate defines the hourly interest rate
    hourly_interest_rate: str = betterproto.string_field(3)
    # next_funding_timestamp defines the next funding timestamp in seconds of a
    # perpetual market
    next_funding_timestamp: int = betterproto.int64_field(4)
    # funding_interval defines the next funding interval in seconds of a
    # perpetual market.
    funding_interval: int = betterproto.int64_field(5)


@dataclass
class PerpetualMarketFunding(betterproto.Message):
    # cumulative_funding defines the cumulative funding of a perpetual market.
    cumulative_funding: str = betterproto.string_field(1)
    # cumulative_price defines the cumulative price for the current hour up to
    # the last timestamp
    cumulative_price: str = betterproto.string_field(2)
    last_timestamp: int = betterproto.int64_field(3)


@dataclass
class DerivativeMarketSettlementInfo(betterproto.Message):
    # market ID.
    market_id: str = betterproto.string_field(1)
    # settlement_price defines the settlement price
    settlement_price: str = betterproto.string_field(2)
    # starting_deficit defines starting deficit
    starting_deficit: str = betterproto.string_field(3)


@dataclass
class NextFundingTimestamp(betterproto.Message):
    next_timestamp: int = betterproto.int64_field(1)


@dataclass
class SpotMarket(betterproto.Message):
    """An object describing trade pair of two assets."""

    # A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
    # asset.
    ticker: str = betterproto.string_field(1)
    # Coin denom used for the base asset
    base_denom: str = betterproto.string_field(2)
    # Coin used for the quote asset
    quote_denom: str = betterproto.string_field(3)
    # maker_fee_rate defines the fee percentage makers pay when trading
    maker_fee_rate: str = betterproto.string_field(4)
    # taker_fee_rate defines the fee percentage takers pay when trading
    taker_fee_rate: str = betterproto.string_field(5)
    # relayer_fee_share_rate defines the percentage of the transaction fee shared
    # with the relayer in a derivative market
    relayer_fee_share_rate: str = betterproto.string_field(6)
    # Unique market ID.
    market_id: str = betterproto.string_field(7)
    # Status of the market
    status: "MarketStatus" = betterproto.enum_field(8)
    # min_price_tick_size defines the minimum tick size that the price required
    # for orders in the market
    min_price_tick_size: str = betterproto.string_field(9)
    # min_quantity_tick_size defines the minimum tick size of the quantity
    # required for orders in the market
    min_quantity_tick_size: str = betterproto.string_field(10)


@dataclass
class Deposit(betterproto.Message):
    """A subaccount's deposit for a given base currency"""

    available_balance: str = betterproto.string_field(1)
    total_balance: str = betterproto.string_field(2)


@dataclass
class SubaccountTradeNonce(betterproto.Message):
    nonce: int = betterproto.uint32_field(1)


@dataclass
class OrderInfo(betterproto.Message):
    # bytes32 subaccount ID that created the order
    subaccount_id: str = betterproto.string_field(1)
    # address fee_recipient address that will receive fees for the order
    fee_recipient: str = betterproto.string_field(2)
    # price of the order
    price: str = betterproto.string_field(3)
    # quantity of the order
    quantity: str = betterproto.string_field(4)


@dataclass
class SpotOrder(betterproto.Message):
    # market_id represents the unique ID of the market
    market_id: str = betterproto.string_field(1)
    # order_info contains the information of the order
    order_info: "OrderInfo" = betterproto.message_field(2)
    # order types
    order_type: "OrderType" = betterproto.enum_field(3)
    # trigger_price is the trigger price used by stop/take orders
    trigger_price: str = betterproto.string_field(4)


@dataclass
class SpotLimitOrder(betterproto.Message):
    """A valid Spot limit order with Metadata."""

    # order_info contains the information of the order
    order_info: "OrderInfo" = betterproto.message_field(1)
    # order types
    order_type: "OrderType" = betterproto.enum_field(2)
    # the amount of the quantity remaining fillable
    fillable: str = betterproto.string_field(3)
    # trigger_price is the trigger price used by stop/take orders
    trigger_price: str = betterproto.string_field(4)
    order_hash: bytes = betterproto.bytes_field(5)


@dataclass
class SpotMarketOrder(betterproto.Message):
    """A valid Spot market order with Metadata."""

    # order_info contains the information of the order
    order_info: "OrderInfo" = betterproto.message_field(1)
    balance_hold: str = betterproto.string_field(2)
    order_hash: bytes = betterproto.bytes_field(3)


@dataclass
class DerivativeOrder(betterproto.Message):
    # market_id represents the unique ID of the market
    market_id: str = betterproto.string_field(1)
    # order_info contains the information of the order
    order_info: "OrderInfo" = betterproto.message_field(2)
    # order types
    order_type: "OrderType" = betterproto.enum_field(3)
    # margin is the margin used by the limit order
    margin: str = betterproto.string_field(4)
    # trigger_price is the trigger price used by stop/take orders
    trigger_price: str = betterproto.string_field(5)


@dataclass
class SubaccountOrderbookMetadata(betterproto.Message):
    vanilla_limit_order_count: int = betterproto.uint32_field(1)
    reduce_only_limit_order_count: int = betterproto.uint32_field(2)
    # AggregateReduceOnlyQuantity is the aggregate fillable quantity of the
    # subaccount's reduce-only limit orders in the given direction.
    aggregate_reduce_only_quantity: str = betterproto.string_field(3)
    # AggregateVanillaQuantity is the aggregate fillable quantity of the
    # subaccount's vanilla limit orders in the given direction.
    aggregate_vanilla_quantity: str = betterproto.string_field(4)


@dataclass
class SubaccountOrder(betterproto.Message):
    # price of the order
    price: str = betterproto.string_field(1)
    # the amount of the quantity remaining fillable
    quantity: str = betterproto.string_field(2)
    is_reduce_only: bool = betterproto.bool_field(3)


@dataclass
class DerivativeLimitOrder(betterproto.Message):
    """A valid Derivative limit order with Metadata."""

    # order_info contains the information of the order
    order_info: "OrderInfo" = betterproto.message_field(1)
    # order types
    order_type: "OrderType" = betterproto.enum_field(2)
    # margin is the margin used by the limit order
    margin: str = betterproto.string_field(3)
    # the amount of the quantity remaining fillable
    fillable: str = betterproto.string_field(4)
    # trigger_price is the trigger price used by stop/take orders
    trigger_price: str = betterproto.string_field(5)
    order_hash: bytes = betterproto.bytes_field(6)


@dataclass
class DerivativeMarketOrder(betterproto.Message):
    """A valid Derivative market order with Metadata."""

    # order_info contains the information of the order
    order_info: "OrderInfo" = betterproto.message_field(1)
    # order types
    order_type: "OrderType" = betterproto.enum_field(2)
    margin: str = betterproto.string_field(3)
    margin_hold: str = betterproto.string_field(4)
    # trigger_price is the trigger price used by stop/take orders
    trigger_price: str = betterproto.string_field(5)
    order_hash: bytes = betterproto.bytes_field(6)


@dataclass
class Position(betterproto.Message):
    is_long: bool = betterproto.bool_field(1)
    quantity: str = betterproto.string_field(2)
    entry_price: str = betterproto.string_field(3)
    margin: str = betterproto.string_field(4)
    cumulative_funding_entry: str = betterproto.string_field(5)


@dataclass
class MarketOrderIndicator(betterproto.Message):
    # market_id represents the unique ID of the market
    market_id: str = betterproto.string_field(1)
    is_buy: bool = betterproto.bool_field(2)


@dataclass
class TradeLog(betterproto.Message):
    quantity: str = betterproto.string_field(1)
    price: str = betterproto.string_field(2)
    # bytes32 subaccount ID that executed the trade
    subaccount_id: bytes = betterproto.bytes_field(3)
    fee: str = betterproto.string_field(4)
    order_hash: bytes = betterproto.bytes_field(5)


@dataclass
class PositionDelta(betterproto.Message):
    is_long: bool = betterproto.bool_field(1)
    execution_quantity: str = betterproto.string_field(2)
    execution_margin: str = betterproto.string_field(3)
    execution_price: str = betterproto.string_field(4)


@dataclass
class DerivativeTradeLog(betterproto.Message):
    subaccount_id: bytes = betterproto.bytes_field(1)
    position_delta: "PositionDelta" = betterproto.message_field(2)
    payout: str = betterproto.string_field(3)
    fee: str = betterproto.string_field(4)
    order_hash: bytes = betterproto.bytes_field(5)


@dataclass
class EventBatchSpotExecution(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    is_buy: bool = betterproto.bool_field(2)
    execution_type: "ExecutionType" = betterproto.enum_field(3)
    trades: List["TradeLog"] = betterproto.message_field(4)


@dataclass
class EventBatchDerivativeExecution(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    is_buy: bool = betterproto.bool_field(2)
    is_liquidation: bool = betterproto.bool_field(3)
    # nil for time expiry futures
    cumulative_funding: str = betterproto.string_field(4)
    execution_type: "ExecutionType" = betterproto.enum_field(5)
    trades: List["DerivativeTradeLog"] = betterproto.message_field(6)


@dataclass
class SubaccountPosition(betterproto.Message):
    position: "Position" = betterproto.message_field(1)
    subaccount_id: bytes = betterproto.bytes_field(2)


@dataclass
class EventBatchDerivativePosition(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    positions: List["SubaccountPosition"] = betterproto.message_field(2)


@dataclass
class EventDerivativeMarketPaused(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    settle_price: str = betterproto.string_field(2)
    total_missing_funds: str = betterproto.string_field(3)
    missing_funds_rate: str = betterproto.string_field(4)


@dataclass
class EventNewSpotOrders(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    buy_orders: List["SpotLimitOrder"] = betterproto.message_field(2)
    sell_orders: List["SpotLimitOrder"] = betterproto.message_field(3)


@dataclass
class EventNewDerivativeOrders(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    buy_orders: List["DerivativeLimitOrder"] = betterproto.message_field(2)
    sell_orders: List["DerivativeLimitOrder"] = betterproto.message_field(3)


@dataclass
class EventCancelSpotOrder(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    order: "SpotLimitOrder" = betterproto.message_field(2)


@dataclass
class EventSpotMarketUpdate(betterproto.Message):
    market: "SpotMarket" = betterproto.message_field(1)


@dataclass
class EventPerpetualMarketUpdate(betterproto.Message):
    market: "DerivativeMarket" = betterproto.message_field(1)
    perpetual_market_info: "PerpetualMarketInfo" = betterproto.message_field(2)
    funding: "PerpetualMarketFunding" = betterproto.message_field(3)


@dataclass
class EventExpiryFuturesMarketUpdate(betterproto.Message):
    market: "DerivativeMarket" = betterproto.message_field(1)
    expiry_futures_market_info: "ExpiryFuturesMarketInfo" = betterproto.message_field(3)


@dataclass
class EventPerpetualMarketFundingUpdate(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    funding: "PerpetualMarketFunding" = betterproto.message_field(2)
    is_hourly_funding: bool = betterproto.bool_field(3)
    funding_rate: str = betterproto.string_field(4)


@dataclass
class EventSubaccountDeposit(betterproto.Message):
    src_address: str = betterproto.string_field(1)
    subaccount_id: bytes = betterproto.bytes_field(2)
    amount: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class EventSubaccountWithdraw(betterproto.Message):
    subaccount_id: bytes = betterproto.bytes_field(1)
    dst_address: str = betterproto.string_field(2)
    amount: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class EventSubaccountBalanceTransfer(betterproto.Message):
    src_subaccount_id: str = betterproto.string_field(1)
    dst_subaccount_id: str = betterproto.string_field(2)
    amount: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class SubaccountDeposit(betterproto.Message):
    subaccount_id: bytes = betterproto.bytes_field(1)
    deposit: "Deposit" = betterproto.message_field(2)


@dataclass
class DepositUpdate(betterproto.Message):
    denom: str = betterproto.string_field(1)
    deposits: List["SubaccountDeposit"] = betterproto.message_field(2)


@dataclass
class EventBatchDepositUpdate(betterproto.Message):
    deposit_updates: List["DepositUpdate"] = betterproto.message_field(1)


@dataclass
class DerivativeMarketOrderCancel(betterproto.Message):
    market_order: "DerivativeMarketOrder" = betterproto.message_field(1)
    cancel_quantity: str = betterproto.string_field(2)


@dataclass
class EventCancelDerivativeOrder(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    is_limit_cancel: bool = betterproto.bool_field(2)
    limit_order: "DerivativeLimitOrder" = betterproto.message_field(3)
    market_order_cancel: "DerivativeMarketOrderCancel" = betterproto.message_field(4)


@dataclass
class LiquidityMiningCampaign(betterproto.Message):
    # spot_market_ids are the marketIDs of the active spot markets in the
    # liquidity mining campaign
    spot_market_ids: List[str] = betterproto.string_field(1)
    # spot_market_weights are the weights for the spot markets
    spot_market_weights: List[str] = betterproto.string_field(2)
    # derivative_market_ids are the marketIDs of the active derivative markets in
    # the liquidity mining campaign
    derivative_market_ids: List[str] = betterproto.string_field(3)
    # derivative_market_weights are the weights for the derivative markets
    derivative_market_weights: List[str] = betterproto.string_field(4)
    # max_epoch_reward_amount is the maximum inj reward amount to be disbursed at
    # the end of the epoch
    max_epoch_reward_amount: str = betterproto.string_field(5)


@dataclass
class MsgDeposit(betterproto.Message):
    """
    MsgDeposit defines a SDK message for transferring coins from the sender's
    bank balance into the subaccount's exchange deposits
    """

    sender: str = betterproto.string_field(1)
    # (Optional) bytes32 subaccount ID to deposit funds into. If empty, the coin
    # will be deposited to the sender's default subaccount address.
    subaccount_id: str = betterproto.string_field(2)
    amount: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class MsgDepositResponse(betterproto.Message):
    """MsgDepositResponse defines the Msg/Deposit response type."""

    pass


@dataclass
class MsgWithdraw(betterproto.Message):
    """
    MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's
    deposits to the user's bank balance
    """

    sender: str = betterproto.string_field(1)
    # bytes32 subaccount ID to withdraw funds from
    subaccount_id: str = betterproto.string_field(2)
    amount: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class MsgWithdrawResponse(betterproto.Message):
    """MsgWithdraw defines the Msg/Withdraw response type."""

    pass


@dataclass
class MsgCreateSpotLimitOrder(betterproto.Message):
    """
    MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit
    order.
    """

    sender: str = betterproto.string_field(1)
    order: "SpotOrder" = betterproto.message_field(2)


@dataclass
class MsgCreateSpotLimitOrderResponse(betterproto.Message):
    """
    MsgCreateSpotLimitOrderResponse defines the Msg/CreateSpotOrder response
    type.
    """

    pass


@dataclass
class MsgBatchCreateSpotLimitOrders(betterproto.Message):
    """
    MsgBatchCreateSpotLimitOrders defines a SDK message for creating a new
    batch of spot limit orders.
    """

    sender: str = betterproto.string_field(1)
    orders: List["SpotOrder"] = betterproto.message_field(2)


@dataclass
class MsgBatchCreateSpotLimitOrdersResponse(betterproto.Message):
    """
    MsgBatchCreateSpotLimitOrdersResponse defines the
    Msg/BatchCreateSpotLimitOrders response type.
    """

    pass


@dataclass
class MsgInstantSpotMarketLaunch(betterproto.Message):
    """
    MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot
    market by paying listing fee without governance
    """

    sender: str = betterproto.string_field(1)
    # Ticker for the spot market.
    ticker: str = betterproto.string_field(2)
    # type of coin to use as the base currency
    base_denom: str = betterproto.string_field(3)
    # type of coin to use as the quote currency
    quote_denom: str = betterproto.string_field(4)
    # min_price_tick_size defines the minimum tick size of the order's price
    min_price_tick_size: str = betterproto.string_field(5)
    # min_quantity_tick_size defines the minimum tick size of the order's
    # quantity
    min_quantity_tick_size: str = betterproto.string_field(6)


@dataclass
class MsgInstantSpotMarketLaunchResponse(betterproto.Message):
    """
    MsgInstantSpotMarketLaunchResponse defines the Msg/InstantSpotMarketLaunch
    response type.
    """

    pass


@dataclass
class MsgInstantPerpetualMarketLaunch(betterproto.Message):
    """
    MsgInstantPerpetualMarketLaunch defines a SDK message for creating a new
    perpetual futures market by paying listing fee without governance
    """

    sender: str = betterproto.string_field(1)
    # Ticker for the derivative market.
    ticker: str = betterproto.string_field(2)
    # type of coin to use as the base currency
    quote_denom: str = betterproto.string_field(3)
    # Oracle base currency
    oracle_base: str = betterproto.string_field(4)
    # Oracle quote currency
    oracle_quote: str = betterproto.string_field(5)
    # Scale factor for oracle prices.
    oracle_scale_factor: int = betterproto.uint32_field(6)
    # Oracle type
    oracle_type: v1beta1.OracleType = betterproto.enum_field(7)
    # maker_fee_rate defines the trade fee rate for makers on the spot market
    maker_fee_rate: str = betterproto.string_field(8)
    # taker_fee_rate defines the trade fee rate for takers on the spot market
    taker_fee_rate: str = betterproto.string_field(9)
    # initial_margin_ratio defines the initial margin ratio for the derivative
    # market
    initial_margin_ratio: str = betterproto.string_field(10)
    # maintenance_margin_ratio defines the maintenance margin ratio for the
    # derivative market
    maintenance_margin_ratio: str = betterproto.string_field(11)
    # min_price_tick_size defines the minimum tick size of the order's price and
    # margin
    min_price_tick_size: str = betterproto.string_field(12)
    # min_quantity_tick_size defines the minimum tick size of the order's
    # quantity
    min_quantity_tick_size: str = betterproto.string_field(13)


@dataclass
class MsgInstantPerpetualMarketLaunchResponse(betterproto.Message):
    """
    MsgInstantPerpetualMarketLaunchResponse defines the
    Msg/InstantPerpetualMarketLaunchResponse response type.
    """

    pass


@dataclass
class MsgInstantExpiryFuturesMarketLaunch(betterproto.Message):
    """
    MsgInstantExpiryFuturesMarketLaunch defines a SDK message for creating a
    new expiry futures market by paying listing fee without governance
    """

    sender: str = betterproto.string_field(1)
    # Ticker for the derivative market.
    ticker: str = betterproto.string_field(2)
    # type of coin to use as the quote currency
    quote_denom: str = betterproto.string_field(3)
    # Oracle base currency
    oracle_base: str = betterproto.string_field(4)
    # Oracle quote currency
    oracle_quote: str = betterproto.string_field(5)
    # Oracle type
    oracle_type: v1beta1.OracleType = betterproto.enum_field(6)
    # Scale factor for oracle prices.
    oracle_scale_factor: int = betterproto.uint32_field(7)
    # Expiration time of the market
    expiry: int = betterproto.int64_field(8)
    # maker_fee_rate defines the trade fee rate for makers on the spot market
    maker_fee_rate: str = betterproto.string_field(9)
    # taker_fee_rate defines the trade fee rate for takers on the spot market
    taker_fee_rate: str = betterproto.string_field(10)
    # initial_margin_ratio defines the initial margin ratio for the derivative
    # market
    initial_margin_ratio: str = betterproto.string_field(11)
    # maintenance_margin_ratio defines the maintenance margin ratio for the
    # derivative market
    maintenance_margin_ratio: str = betterproto.string_field(12)
    # min_price_tick_size defines the minimum tick size of the order's price and
    # margin
    min_price_tick_size: str = betterproto.string_field(13)
    # min_quantity_tick_size defines the minimum tick size of the order's
    # quantity
    min_quantity_tick_size: str = betterproto.string_field(14)


@dataclass
class MsgInstantExpiryFuturesMarketLaunchResponse(betterproto.Message):
    """
    MsgInstantExpiryFuturesMarketLaunchResponse defines the
    Msg/InstantExpiryFuturesMarketLaunch response type.
    """

    pass


@dataclass
class MsgCreateSpotMarketOrder(betterproto.Message):
    """
    MsgCreateSpotMarketOrder defines a SDK message for creating a new spot
    market order.
    """

    sender: str = betterproto.string_field(1)
    order: "SpotOrder" = betterproto.message_field(2)


@dataclass
class MsgCreateSpotMarketOrderResponse(betterproto.Message):
    """
    MsgCreateSpotMarketOrderResponse defines the Msg/CreateSpotMarketLimitOrder
    response type.
    """

    pass


@dataclass
class MsgCreateDerivativeLimitOrder(betterproto.Message):
    """A Cosmos-SDK MsgCreateDerivativeLimitOrder"""

    sender: str = betterproto.string_field(1)
    order: "DerivativeOrder" = betterproto.message_field(2)


@dataclass
class MsgCreateDerivativeLimitOrderResponse(betterproto.Message):
    """
    MsgCreateDerivativeLimitOrderResponse defines the
    Msg/CreateDerivativeMarketOrder response type.
    """

    pass


@dataclass
class MsgBatchCreateDerivativeLimitOrders(betterproto.Message):
    """A Cosmos-SDK MsgBatchCreateDerivativeLimitOrders"""

    sender: str = betterproto.string_field(1)
    orders: List["DerivativeOrder"] = betterproto.message_field(2)


@dataclass
class MsgBatchCreateDerivativeLimitOrdersResponse(betterproto.Message):
    """
    MsgBatchCreateDerivativeLimitOrdersResponse defines the
    Msg/BatchCreateDerivativeLimitOrders response type.
    """

    pass


@dataclass
class MsgCancelSpotOrder(betterproto.Message):
    """MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type."""

    sender: str = betterproto.string_field(1)
    market_id: str = betterproto.string_field(2)
    subaccount_id: str = betterproto.string_field(3)
    order_hash: str = betterproto.string_field(4)


@dataclass
class MsgCancelSpotOrderResponse(betterproto.Message):
    """
    MsgCancelSpotOrderResponse defines the Msg/CancelSpotOrder response type.
    """

    pass


@dataclass
class MsgBatchCancelSpotOrders(betterproto.Message):
    """
    MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response
    type.
    """

    sender: str = betterproto.string_field(1)
    data: List["OrderData"] = betterproto.message_field(2)


@dataclass
class MsgBatchCancelSpotOrdersResponse(betterproto.Message):
    """
    MsgBatchCancelSpotOrdersResponse defines the Msg/BatchCancelSpotOrders
    response type.
    """

    pass


@dataclass
class MsgCreateDerivativeMarketOrder(betterproto.Message):
    """A Cosmos-SDK MsgCreateDerivativeMarketOrder"""

    sender: str = betterproto.string_field(1)
    order: "DerivativeOrder" = betterproto.message_field(2)


@dataclass
class MsgCreateDerivativeMarketOrderResponse(betterproto.Message):
    """
    MsgCreateDerivativeMarketOrderResponse defines the
    Msg/CreateDerivativeMarketOrder response type.
    """

    pass


@dataclass
class MsgCancelDerivativeOrder(betterproto.Message):
    """
    MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response
    type.
    """

    sender: str = betterproto.string_field(1)
    market_id: str = betterproto.string_field(2)
    subaccount_id: str = betterproto.string_field(3)
    order_hash: str = betterproto.string_field(4)


@dataclass
class MsgCancelDerivativeOrderResponse(betterproto.Message):
    """
    MsgCancelDerivativeOrderResponse defines the
    Msg/CancelDerivativeOrderResponse response type.
    """

    pass


@dataclass
class OrderData(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    subaccount_id: str = betterproto.string_field(2)
    order_hash: str = betterproto.string_field(3)


@dataclass
class MsgBatchCancelDerivativeOrders(betterproto.Message):
    """
    MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders
    response type.
    """

    sender: str = betterproto.string_field(1)
    data: List["OrderData"] = betterproto.message_field(2)


@dataclass
class MsgBatchCancelDerivativeOrdersResponse(betterproto.Message):
    """
    MsgBatchCancelDerivativeOrdersResponse defines the
    Msg/CancelDerivativeOrderResponse response type.
    """

    pass


@dataclass
class MsgSubaccountTransfer(betterproto.Message):
    """A Cosmos-SDK MsgSubaccountTransfer"""

    sender: str = betterproto.string_field(1)
    source_subaccount_id: str = betterproto.string_field(2)
    destination_subaccount_id: str = betterproto.string_field(3)
    amount: v1beta1.Coin = betterproto.message_field(4)


@dataclass
class MsgSubaccountTransferResponse(betterproto.Message):
    """
    MsgSubaccountTransferResponse defines the Msg/SubaccountTransfer response
    type.
    """

    pass


@dataclass
class MsgExternalTransfer(betterproto.Message):
    """A Cosmos-SDK MsgExternalTransfer"""

    sender: str = betterproto.string_field(1)
    source_subaccount_id: str = betterproto.string_field(2)
    destination_subaccount_id: str = betterproto.string_field(3)
    amount: v1beta1.Coin = betterproto.message_field(4)


@dataclass
class MsgExternalTransferResponse(betterproto.Message):
    """
    MsgExternalTransferResponse defines the Msg/ExternalTransfer response type.
    """

    pass


@dataclass
class MsgLiquidatePosition(betterproto.Message):
    """A Cosmos-SDK MsgLiquidatePosition"""

    sender: str = betterproto.string_field(1)
    subaccount_id: str = betterproto.string_field(2)
    market_id: str = betterproto.string_field(3)
    # optional order to provide for liquidation
    order: "DerivativeOrder" = betterproto.message_field(4)


@dataclass
class MsgLiquidatePositionResponse(betterproto.Message):
    """
    MsgLiquidatePositionResponse defines the Msg/LiquidatePosition response
    type.
    """

    pass


@dataclass
class MsgIncreasePositionMargin(betterproto.Message):
    """A Cosmos-SDK MsgIncreasePositionMargin"""

    sender: str = betterproto.string_field(1)
    source_subaccount_id: str = betterproto.string_field(2)
    destination_subaccount_id: str = betterproto.string_field(3)
    market_id: str = betterproto.string_field(4)
    # amount defines the amount of margin to add to the position
    amount: str = betterproto.string_field(5)


@dataclass
class MsgIncreasePositionMarginResponse(betterproto.Message):
    """
    MsgIncreasePositionMarginResponse defines the Msg/IncreasePositionMargin
    response type.
    """

    pass


@dataclass
class SpotMarketParamUpdateProposal(betterproto.Message):
    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    market_id: str = betterproto.string_field(3)
    # maker_fee_rate defines the trade fee rate for makers on the spot market
    maker_fee_rate: str = betterproto.string_field(4)
    # taker_fee_rate defines the trade fee rate for takers on the spot market
    taker_fee_rate: str = betterproto.string_field(5)
    # relayer_fee_share_rate defines the relayer fee share rate for the spot
    # market
    relayer_fee_share_rate: str = betterproto.string_field(6)
    # min_price_tick_size defines the minimum tick size of the order's price and
    # margin
    min_price_tick_size: str = betterproto.string_field(7)
    # min_quantity_tick_size defines the minimum tick size of the order's
    # quantity
    min_quantity_tick_size: str = betterproto.string_field(8)
    status: "MarketStatus" = betterproto.enum_field(9)


@dataclass
class ExchangeEnableProposal(betterproto.Message):
    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    exchange_type: "ExchangeType" = betterproto.enum_field(3)


@dataclass
class SpotMarketLaunchProposal(betterproto.Message):
    """
    SpotMarketLaunchProposal defines a SDK message for proposing a new spot
    market through governance
    """

    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    # Ticker for the spot market.
    ticker: str = betterproto.string_field(3)
    # type of coin to use as the base currency
    base_denom: str = betterproto.string_field(4)
    # type of coin to use as the quote currency
    quote_denom: str = betterproto.string_field(5)
    # min_price_tick_size defines the minimum tick size of the order's price
    min_price_tick_size: str = betterproto.string_field(6)
    # min_quantity_tick_size defines the minimum tick size of the order's
    # quantity
    min_quantity_tick_size: str = betterproto.string_field(7)


@dataclass
class PerpetualMarketLaunchProposal(betterproto.Message):
    """
    PerpetualMarketLaunchProposal defines a SDK message for proposing a new
    perpetual futures market through governance
    """

    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    # Ticker for the derivative market.
    ticker: str = betterproto.string_field(3)
    # type of coin to use as the base currency
    quote_denom: str = betterproto.string_field(4)
    # Oracle base currency
    oracle_base: str = betterproto.string_field(5)
    # Oracle quote currency
    oracle_quote: str = betterproto.string_field(6)
    # Scale factor for oracle prices.
    oracle_scale_factor: int = betterproto.uint32_field(7)
    # Oracle type
    oracle_type: v1beta1.OracleType = betterproto.enum_field(8)
    # initial_margin_ratio defines the initial margin ratio for the derivative
    # market
    initial_margin_ratio: str = betterproto.string_field(9)
    # maintenance_margin_ratio defines the maintenance margin ratio for the
    # derivative market
    maintenance_margin_ratio: str = betterproto.string_field(10)
    # maker_fee_rate defines the exchange trade fee for makers for the derivative
    # market
    maker_fee_rate: str = betterproto.string_field(11)
    # taker_fee_rate defines the exchange trade fee for takers for the derivative
    # market
    taker_fee_rate: str = betterproto.string_field(12)
    # min_price_tick_size defines the minimum tick size of the order's price and
    # margin
    min_price_tick_size: str = betterproto.string_field(13)
    # min_quantity_tick_size defines the minimum tick size of the order's
    # quantity
    min_quantity_tick_size: str = betterproto.string_field(14)


@dataclass
class ExpiryFuturesMarketLaunchProposal(betterproto.Message):
    """
    ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new
    expiry futures market through governance
    """

    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    # Ticker for the derivative market.
    ticker: str = betterproto.string_field(3)
    # type of coin to use as the quote currency
    quote_denom: str = betterproto.string_field(4)
    # Oracle base currency
    oracle_base: str = betterproto.string_field(5)
    # Oracle quote currency
    oracle_quote: str = betterproto.string_field(6)
    # Scale factor for oracle prices.
    oracle_scale_factor: int = betterproto.uint32_field(7)
    # Oracle type
    oracle_type: v1beta1.OracleType = betterproto.enum_field(8)
    # Expiration time of the market
    expiry: int = betterproto.int64_field(9)
    # initial_margin_ratio defines the initial margin ratio for the derivative
    # market
    initial_margin_ratio: str = betterproto.string_field(10)
    # maintenance_margin_ratio defines the maintenance margin ratio for the
    # derivative market
    maintenance_margin_ratio: str = betterproto.string_field(11)
    # maker_fee_rate defines the exchange trade fee for makers for the derivative
    # market
    maker_fee_rate: str = betterproto.string_field(12)
    # taker_fee_rate defines the exchange trade fee for takers for the derivative
    # market
    taker_fee_rate: str = betterproto.string_field(13)
    # min_price_tick_size defines the minimum tick size of the order's price and
    # margin
    min_price_tick_size: str = betterproto.string_field(14)
    # min_quantity_tick_size defines the minimum tick size of the order's
    # quantity
    min_quantity_tick_size: str = betterproto.string_field(15)


@dataclass
class DerivativeMarketParamUpdateProposal(betterproto.Message):
    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    market_id: str = betterproto.string_field(3)
    # initial_margin_ratio defines the initial margin ratio for the derivative
    # market
    initial_margin_ratio: str = betterproto.string_field(4)
    # maintenance_margin_ratio defines the maintenance margin ratio for the
    # derivative market
    maintenance_margin_ratio: str = betterproto.string_field(5)
    # maker_fee_rate defines the exchange trade fee for makers for the derivative
    # market
    maker_fee_rate: str = betterproto.string_field(6)
    # taker_fee_rate defines the exchange trade fee for takers for the derivative
    # market
    taker_fee_rate: str = betterproto.string_field(7)
    # relayer_fee_share_rate defines the relayer fee share rate for the
    # derivative market
    relayer_fee_share_rate: str = betterproto.string_field(8)
    # min_price_tick_size defines the minimum tick size of the order's price and
    # margin
    min_price_tick_size: str = betterproto.string_field(9)
    # min_quantity_tick_size defines the minimum tick size of the order's
    # quantity
    min_quantity_tick_size: str = betterproto.string_field(10)
    # hourly_interest_rate defines the hourly interest rate
    hourly_interest_rate: str = betterproto.string_field(11)
    # hourly_funding_rate_cap defines the maximum absolute value of the hourly
    # funding rate
    hourly_funding_rate_cap: str = betterproto.string_field(12)
    status: "MarketStatus" = betterproto.enum_field(13)


@dataclass
class DerivativeMarketBandOraclePromotionProposal(betterproto.Message):
    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    market_id: str = betterproto.string_field(3)


@dataclass
class LiquidityMiningCampaignProposal(betterproto.Message):
    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    campaign: "LiquidityMiningCampaign" = betterproto.message_field(3)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState defines the evm module's genesis state."""

    # params defines all the parameters of related to exchange.
    params: "Params" = betterproto.message_field(1)
    # accounts is an array containing the genesis trade pairs
    spot_markets: List["SpotMarket"] = betterproto.message_field(2)
    # accounts is an array containing the genesis derivative markets
    derivative_markets: List["DerivativeMarket"] = betterproto.message_field(3)
    # spot_orderbook defines the spot exchange limit orderbook active at genesis.
    spot_orderbook: List["SpotOrderBook"] = betterproto.message_field(4)
    # derivative_orderbook defines the derivative exchange limit orderbook active
    # at genesis.
    derivative_orderbook: List["DerivativeOrderBook"] = betterproto.message_field(5)
    # balances defines the exchange users balances active at genesis.
    balances: List["Balance"] = betterproto.message_field(6)
    # positions defines the exchange derivative positions at genesis
    positions: List["DerivativePosition"] = betterproto.message_field(7)
    # subaccount_trade_nonces defines the subaccount trade nonces for the
    # subaccounts at genesis
    subaccount_trade_nonces: List["SubaccountNonce"] = betterproto.message_field(8)
    # expiry_futures_market_info defines the market info for the expiry futures
    # markets at genesis
    expiry_futures_market_info_state: List[
        "ExpiryFuturesMarketInfoState"
    ] = betterproto.message_field(9)
    # perpetual_market_info defines the market info for the perpetual derivative
    # markets at genesis
    perpetual_market_info: List["PerpetualMarketInfo"] = betterproto.message_field(10)
    # perpetual_market_funding_state defines the funding state for the perpetual
    # derivative markets at genesis
    perpetual_market_funding_state: List[
        "PerpetualMarketFundingState"
    ] = betterproto.message_field(11)
    # derivative_market_settlement_scheduled defines the scheduled markets for
    # settlement at genesis
    derivative_market_settlement_scheduled: List[
        "DerivativeMarketSettlementInfo"
    ] = betterproto.message_field(12)
    is_spot_exchange_enabled: bool = betterproto.bool_field(13)
    is_derivatives_exchange_enabled: bool = betterproto.bool_field(14)
    liquidity_mining_account_points: List[
        "LiquidityMiningAccountPoints"
    ] = betterproto.message_field(15)
    current_liquidity_mining_campaign: "LiquidityMiningCampaign" = (
        betterproto.message_field(16)
    )
    upcoming_liquidity_mining_campaign: "LiquidityMiningCampaign" = (
        betterproto.message_field(17)
    )


@dataclass
class SpotOrderBook(betterproto.Message):
    """Spot Exchange Limit Orderbook"""

    market_id: str = betterproto.string_field(1)
    is_buy_side: bool = betterproto.bool_field(2)
    orders: List["SpotLimitOrder"] = betterproto.message_field(3)


@dataclass
class DerivativeOrderBook(betterproto.Message):
    """Spot Exchange Limit Orderbook"""

    market_id: str = betterproto.string_field(1)
    is_buy_side: bool = betterproto.bool_field(2)
    orders: List["DerivativeLimitOrder"] = betterproto.message_field(3)


@dataclass
class Balance(betterproto.Message):
    subaccount_id: str = betterproto.string_field(1)
    denom: str = betterproto.string_field(2)
    deposits: "Deposit" = betterproto.message_field(3)


@dataclass
class DerivativePosition(betterproto.Message):
    subaccount_id: str = betterproto.string_field(1)
    market_id: str = betterproto.string_field(2)
    position: "Position" = betterproto.message_field(3)


@dataclass
class SubaccountNonce(betterproto.Message):
    subaccount_id: str = betterproto.string_field(1)
    subaccount_trade_nonce: "SubaccountTradeNonce" = betterproto.message_field(2)


@dataclass
class ExpiryFuturesMarketInfoState(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    market_info: "ExpiryFuturesMarketInfo" = betterproto.message_field(2)


@dataclass
class PerpetualMarketFundingState(betterproto.Message):
    market_id: str = betterproto.string_field(1)
    funding: "PerpetualMarketFunding" = betterproto.message_field(2)


@dataclass
class LiquidityMiningAccountPoints(betterproto.Message):
    account: str = betterproto.string_field(1)
    points: str = betterproto.string_field(2)


@dataclass
class Subaccount(betterproto.Message):
    trader: str = betterproto.string_field(1)
    subaccount_nonce: int = betterproto.uint32_field(2)


@dataclass
class QueryExchangeParamsRequest(betterproto.Message):
    """
    QueryExchangeParamsRequest is the request type for the Query/ExchangeParams
    RPC method.
    """

    pass


@dataclass
class QueryExchangeParamsResponse(betterproto.Message):
    """
    QueryExchangeParamsRequest is the response type for the
    Query/ExchangeParams RPC method.
    """

    params: "Params" = betterproto.message_field(1)


@dataclass
class QuerySubaccountDepositsRequest(betterproto.Message):
    """
    QuerySubaccountDepositsRequest is the request type for the
    Query/SubaccountDeposits RPC method.
    """

    subaccount_id: str = betterproto.string_field(1)
    subaccount: "Subaccount" = betterproto.message_field(2)


@dataclass
class QuerySubaccountDepositsResponse(betterproto.Message):
    """
    QuerySubaccountDepositsResponse is the response type for the
    Query/SubaccountDeposits RPC method.
    """

    deposits: Dict[str, "Deposit"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class QueryExchangeBalancesRequest(betterproto.Message):
    """
    QueryExchangeBalancesRequest is the request type for the
    Query/ExchangeBalances RPC method.
    """

    pass


@dataclass
class QueryExchangeBalancesResponse(betterproto.Message):
    """
    QuerySubaccountDepositsResponse is the response type for the
    Query/SubaccountDeposits RPC method.
    """

    balances: List["Balance"] = betterproto.message_field(1)


@dataclass
class QuerySubaccountDepositRequest(betterproto.Message):
    """
    QuerySubaccountDepositsRequest is the request type for the
    Query/SubaccountDeposits RPC method.
    """

    subaccount_id: str = betterproto.string_field(1)
    denom: str = betterproto.string_field(2)


@dataclass
class QuerySubaccountDepositResponse(betterproto.Message):
    """
    QuerySubaccountDepositsResponse is the response type for the
    Query/SubaccountDeposits RPC method.
    """

    deposits: "Deposit" = betterproto.message_field(1)


@dataclass
class QuerySpotMarketsRequest(betterproto.Message):
    """
    QuerySpotMarketsRequest is the request type for the Query/SpotMarkets RPC
    method.
    """

    # Status of the market, for convenience it is set to string - not enum
    status: str = betterproto.string_field(1)


@dataclass
class QuerySpotMarketsResponse(betterproto.Message):
    """
    QuerySpotMarketsResponse is the response type for the Query/SpotMarkets RPC
    method.
    """

    markets: List["SpotMarket"] = betterproto.message_field(1)


@dataclass
class QuerySpotMarketRequest(betterproto.Message):
    """
    QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
    method.
    """

    # Market ID for the market
    market_id: str = betterproto.string_field(1)


@dataclass
class QuerySpotMarketResponse(betterproto.Message):
    """
    QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
    method.
    """

    market: "SpotMarket" = betterproto.message_field(1)


@dataclass
class QuerySpotOrderbookRequest(betterproto.Message):
    """
    QuerySpotOrderbookRequest is the request type for the Query/SpotOrderbook
    RPC method.
    """

    # Market ID for the market
    market_id: str = betterproto.string_field(1)
    limit: int = betterproto.uint64_field(2)


@dataclass
class QuerySpotOrderbookResponse(betterproto.Message):
    """
    QuerySpotOrderbookResponse is the response type for the Query/SpotOrderbook
    RPC method.
    """

    buys_price_level: List["PriceLevel"] = betterproto.message_field(1)
    sells_price_level: List["PriceLevel"] = betterproto.message_field(2)


@dataclass
class QueryTraderSpotOrdersRequest(betterproto.Message):
    """
    QueryTraderSpotOrdersRequest is the request type for the
    Query/TraderSpotOrders RPC method.
    """

    # Market ID for the market
    market_id: str = betterproto.string_field(1)
    # SubaccountID of the trader
    subaccount_id: str = betterproto.string_field(2)


@dataclass
class TrimmedSpotLimitOrder(betterproto.Message):
    # price of the order
    price: str = betterproto.string_field(1)
    # quantity of the order
    quantity: str = betterproto.string_field(2)
    # the amount of the quantity remaining fillable
    fillable: str = betterproto.string_field(3)
    # true if the order is a buy
    is_buy: bool = betterproto.bool_field(4)
    order_hash: str = betterproto.string_field(5)


@dataclass
class QueryTraderSpotOrdersResponse(betterproto.Message):
    """
    QueryTraderSpotOrdersResponse is the response type for the
    Query/TraderSpotOrders RPC method.
    """

    orders: List["TrimmedSpotLimitOrder"] = betterproto.message_field(1)


@dataclass
class QueryDerivativeOrderbookRequest(betterproto.Message):
    """
    QueryDerivativeOrderbookRequest is the request type for the
    Query/DerivativeOrderbook RPC method.
    """

    # Market ID for the market
    market_id: str = betterproto.string_field(1)
    limit: int = betterproto.uint64_field(2)


@dataclass
class QueryDerivativeOrderbookResponse(betterproto.Message):
    """
    QueryDerivativeOrderbookResponse is the response type for the
    Query/DerivativeOrderbook RPC method.
    """

    buys_price_level: List["PriceLevel"] = betterproto.message_field(1)
    sells_price_level: List["PriceLevel"] = betterproto.message_field(2)


@dataclass
class QueryTraderDerivativeOrdersRequest(betterproto.Message):
    """
    QueryTraderDerivativeOrdersRequest is the request type for the
    Query/TraderDerivativeOrders RPC method.
    """

    # Market ID for the market
    market_id: str = betterproto.string_field(1)
    # SubaccountID of the trader
    subaccount_id: str = betterproto.string_field(2)


@dataclass
class TrimmedDerivativeLimitOrder(betterproto.Message):
    # price of the order
    price: str = betterproto.string_field(1)
    # quantity of the order
    quantity: str = betterproto.string_field(2)
    # margin of the order
    margin: str = betterproto.string_field(3)
    # the amount of the quantity remaining fillable
    fillable: str = betterproto.string_field(4)
    # true if the order is a buy
    is_buy: bool = betterproto.bool_field(5)
    order_hash: str = betterproto.string_field(6)


@dataclass
class QueryTraderDerivativeOrdersResponse(betterproto.Message):
    """
    QueryTraderDerivativeOrdersResponse is the response type for the
    Query/TraderDerivativeOrders RPC method.
    """

    orders: List["TrimmedDerivativeLimitOrder"] = betterproto.message_field(1)


@dataclass
class QueryDerivativeMarketsRequest(betterproto.Message):
    """
    QueryDerivativeMarketsRequest is the request type for the
    Query/DerivativeMarkets RPC method.
    """

    # Status of the market, for convenience it is set to string - not enum
    status: str = betterproto.string_field(1)


@dataclass
class PriceLevel(betterproto.Message):
    price: str = betterproto.string_field(1)
    # quantity
    quantity: str = betterproto.string_field(2)


@dataclass
class PerpetualMarketState(betterproto.Message):
    market_info: "PerpetualMarketInfo" = betterproto.message_field(1)
    funding_info: "PerpetualMarketFunding" = betterproto.message_field(2)


@dataclass
class FullDerivativeMarket(betterproto.Message):
    market: "DerivativeMarket" = betterproto.message_field(1)
    perpetual_info: "PerpetualMarketState" = betterproto.message_field(2, group="info")
    futures_info: "ExpiryFuturesMarketInfo" = betterproto.message_field(3, group="info")
    mark_price: str = betterproto.string_field(4)


@dataclass
class QueryDerivativeMarketsResponse(betterproto.Message):
    """
    QueryDerivativeMarketsResponse is the response type for the
    Query/DerivativeMarkets RPC method.
    """

    markets: List["FullDerivativeMarket"] = betterproto.message_field(1)


@dataclass
class QueryDerivativeMarketRequest(betterproto.Message):
    """
    QueryDerivativeMarketRequest is the request type for the
    Query/DerivativeMarket RPC method.
    """

    # Market ID for the market
    market_id: str = betterproto.string_field(1)


@dataclass
class QueryDerivativeMarketResponse(betterproto.Message):
    """
    QueryDerivativeMarketResponse is the response type for the
    Query/DerivativeMarket RPC method.
    """

    market: "FullDerivativeMarket" = betterproto.message_field(1)


@dataclass
class QuerySubaccountTradeNonceRequest(betterproto.Message):
    """
    QuerySubaccountTradeNonceRequest is the request type for the
    Query/SubaccountTradeNonce RPC method.
    """

    subaccount_id: str = betterproto.string_field(1)


@dataclass
class QuerySubaccountTradeNonceResponse(betterproto.Message):
    """
    QuerySubaccountTradeNonceResponse is the response type for the
    Query/SubaccountTradeNonce RPC method.
    """

    nonce: int = betterproto.uint32_field(1)


@dataclass
class QueryModuleStateRequest(betterproto.Message):
    """
    QueryModuleStateRequest is the request type for the
    Query/ExchangeModuleState RPC method.
    """

    pass


@dataclass
class QueryModuleStateResponse(betterproto.Message):
    """
    QueryModuleStateResponse is the response type for the
    Query/ExchangeModuleState RPC method.
    """

    state: "GenesisState" = betterproto.message_field(1)


@dataclass
class QueryPositionsRequest(betterproto.Message):
    """
    QueryPositionsRequest is the request type for the Query/Positions RPC
    method.
    """

    pass


@dataclass
class QueryPositionsResponse(betterproto.Message):
    """
    QueryPositionsResponse is the response type for the Query/Positions RPC
    method.
    """

    state: List["DerivativePosition"] = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the staking Msg service."""

    async def deposit(
        self,
        *,
        sender: str = "",
        subaccount_id: str = "",
        amount: Optional[v1beta1.Coin] = None,
    ) -> MsgDepositResponse:
        """
        Deposit defines a method for transferring coins from the sender's bank
        balance into the subaccount's exchange deposits
        """

        request = MsgDeposit()
        request.sender = sender
        request.subaccount_id = subaccount_id
        if amount is not None:
            request.amount = amount

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/Deposit",
            request,
            MsgDepositResponse,
        )

    async def withdraw(
        self,
        *,
        sender: str = "",
        subaccount_id: str = "",
        amount: Optional[v1beta1.Coin] = None,
    ) -> MsgWithdrawResponse:
        """
        Withdraw defines a method for withdrawing coins from a subaccount's
        deposits to the user's bank balance
        """

        request = MsgWithdraw()
        request.sender = sender
        request.subaccount_id = subaccount_id
        if amount is not None:
            request.amount = amount

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/Withdraw",
            request,
            MsgWithdrawResponse,
        )

    async def instant_spot_market_launch(
        self,
        *,
        sender: str = "",
        ticker: str = "",
        base_denom: str = "",
        quote_denom: str = "",
        min_price_tick_size: str = "",
        min_quantity_tick_size: str = "",
    ) -> MsgInstantSpotMarketLaunchResponse:
        """
        InstantSpotMarketLaunch defines method for creating a spot market by
        paying listing fee without governance
        """

        request = MsgInstantSpotMarketLaunch()
        request.sender = sender
        request.ticker = ticker
        request.base_denom = base_denom
        request.quote_denom = quote_denom
        request.min_price_tick_size = min_price_tick_size
        request.min_quantity_tick_size = min_quantity_tick_size

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/InstantSpotMarketLaunch",
            request,
            MsgInstantSpotMarketLaunchResponse,
        )

    async def instant_perpetual_market_launch(
        self,
        *,
        sender: str = "",
        ticker: str = "",
        quote_denom: str = "",
        oracle_base: str = "",
        oracle_quote: str = "",
        oracle_scale_factor: int = 0,
        oracle_type: v1beta1.OracleType = 0,
        maker_fee_rate: str = "",
        taker_fee_rate: str = "",
        initial_margin_ratio: str = "",
        maintenance_margin_ratio: str = "",
        min_price_tick_size: str = "",
        min_quantity_tick_size: str = "",
    ) -> MsgInstantPerpetualMarketLaunchResponse:
        """
        InstantPerpetualMarketLaunch defines a method for creating a new
        perpetual futures market by paying listing fee without governance
        """

        request = MsgInstantPerpetualMarketLaunch()
        request.sender = sender
        request.ticker = ticker
        request.quote_denom = quote_denom
        request.oracle_base = oracle_base
        request.oracle_quote = oracle_quote
        request.oracle_scale_factor = oracle_scale_factor
        request.oracle_type = oracle_type
        request.maker_fee_rate = maker_fee_rate
        request.taker_fee_rate = taker_fee_rate
        request.initial_margin_ratio = initial_margin_ratio
        request.maintenance_margin_ratio = maintenance_margin_ratio
        request.min_price_tick_size = min_price_tick_size
        request.min_quantity_tick_size = min_quantity_tick_size

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/InstantPerpetualMarketLaunch",
            request,
            MsgInstantPerpetualMarketLaunchResponse,
        )

    async def instant_expiry_futures_market_launch(
        self,
        *,
        sender: str = "",
        ticker: str = "",
        quote_denom: str = "",
        oracle_base: str = "",
        oracle_quote: str = "",
        oracle_type: v1beta1.OracleType = 0,
        oracle_scale_factor: int = 0,
        expiry: int = 0,
        maker_fee_rate: str = "",
        taker_fee_rate: str = "",
        initial_margin_ratio: str = "",
        maintenance_margin_ratio: str = "",
        min_price_tick_size: str = "",
        min_quantity_tick_size: str = "",
    ) -> MsgInstantExpiryFuturesMarketLaunchResponse:
        """
        InstantExpiryFuturesMarketLaunch defines a method for creating a new
        expiry futures market by paying listing fee without governance
        """

        request = MsgInstantExpiryFuturesMarketLaunch()
        request.sender = sender
        request.ticker = ticker
        request.quote_denom = quote_denom
        request.oracle_base = oracle_base
        request.oracle_quote = oracle_quote
        request.oracle_type = oracle_type
        request.oracle_scale_factor = oracle_scale_factor
        request.expiry = expiry
        request.maker_fee_rate = maker_fee_rate
        request.taker_fee_rate = taker_fee_rate
        request.initial_margin_ratio = initial_margin_ratio
        request.maintenance_margin_ratio = maintenance_margin_ratio
        request.min_price_tick_size = min_price_tick_size
        request.min_quantity_tick_size = min_quantity_tick_size

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/InstantExpiryFuturesMarketLaunch",
            request,
            MsgInstantExpiryFuturesMarketLaunchResponse,
        )

    async def create_spot_limit_order(
        self, *, sender: str = "", order: Optional["SpotOrder"] = None
    ) -> MsgCreateSpotLimitOrderResponse:
        """
        CreateSpotLimitOrder defines a method for creating a new spot limit
        order.
        """

        request = MsgCreateSpotLimitOrder()
        request.sender = sender
        if order is not None:
            request.order = order

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/CreateSpotLimitOrder",
            request,
            MsgCreateSpotLimitOrderResponse,
        )

    async def batch_create_spot_limit_orders(
        self, *, sender: str = "", orders: List["SpotOrder"] = []
    ) -> MsgBatchCreateSpotLimitOrdersResponse:
        """
        BatchCreateSpotLimitOrder defines a method for creating a new batch of
        spot limit orders.
        """

        request = MsgBatchCreateSpotLimitOrders()
        request.sender = sender
        if orders is not None:
            request.orders = orders

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/BatchCreateSpotLimitOrders",
            request,
            MsgBatchCreateSpotLimitOrdersResponse,
        )

    async def create_spot_market_order(
        self, *, sender: str = "", order: Optional["SpotOrder"] = None
    ) -> MsgCreateSpotMarketOrderResponse:
        """
        CreateSpotMarketOrder defines a method for creating a new spot market
        order.
        """

        request = MsgCreateSpotMarketOrder()
        request.sender = sender
        if order is not None:
            request.order = order

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/CreateSpotMarketOrder",
            request,
            MsgCreateSpotMarketOrderResponse,
        )

    async def cancel_spot_order(
        self,
        *,
        sender: str = "",
        market_id: str = "",
        subaccount_id: str = "",
        order_hash: str = "",
    ) -> MsgCancelSpotOrderResponse:
        """MsgCancelSpotOrder defines a method for cancelling a spot order."""

        request = MsgCancelSpotOrder()
        request.sender = sender
        request.market_id = market_id
        request.subaccount_id = subaccount_id
        request.order_hash = order_hash

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/CancelSpotOrder",
            request,
            MsgCancelSpotOrderResponse,
        )

    async def batch_cancel_spot_orders(
        self, *, sender: str = "", data: List["OrderData"] = []
    ) -> MsgBatchCancelSpotOrdersResponse:
        """
        BatchCancelSpotOrders defines a method for cancelling a batch of spot
        orders in a given market.
        """

        request = MsgBatchCancelSpotOrders()
        request.sender = sender
        if data is not None:
            request.data = data

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/BatchCancelSpotOrders",
            request,
            MsgBatchCancelSpotOrdersResponse,
        )

    async def create_derivative_limit_order(
        self, *, sender: str = "", order: Optional["DerivativeOrder"] = None
    ) -> MsgCreateDerivativeLimitOrderResponse:
        """
        CreateDerivativeLimitOrder defines a method for creating a new
        derivative limit order.
        """

        request = MsgCreateDerivativeLimitOrder()
        request.sender = sender
        if order is not None:
            request.order = order

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/CreateDerivativeLimitOrder",
            request,
            MsgCreateDerivativeLimitOrderResponse,
        )

    async def batch_create_derivative_limit_orders(
        self, *, sender: str = "", orders: List["DerivativeOrder"] = []
    ) -> MsgBatchCreateDerivativeLimitOrdersResponse:
        """
        BatchCreateDerivativeLimitOrders defines a method for creating a new
        batch of derivative limit orders.
        """

        request = MsgBatchCreateDerivativeLimitOrders()
        request.sender = sender
        if orders is not None:
            request.orders = orders

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/BatchCreateDerivativeLimitOrders",
            request,
            MsgBatchCreateDerivativeLimitOrdersResponse,
        )

    async def create_derivative_market_order(
        self, *, sender: str = "", order: Optional["DerivativeOrder"] = None
    ) -> MsgCreateDerivativeMarketOrderResponse:
        """
        MsgCreateDerivativeLimitOrder defines a method for creating a new
        derivative market order.
        """

        request = MsgCreateDerivativeMarketOrder()
        request.sender = sender
        if order is not None:
            request.order = order

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/CreateDerivativeMarketOrder",
            request,
            MsgCreateDerivativeMarketOrderResponse,
        )

    async def cancel_derivative_order(
        self,
        *,
        sender: str = "",
        market_id: str = "",
        subaccount_id: str = "",
        order_hash: str = "",
    ) -> MsgCancelDerivativeOrderResponse:
        """
        MsgCancelDerivativeOrder defines a method for cancelling a derivative
        order.
        """

        request = MsgCancelDerivativeOrder()
        request.sender = sender
        request.market_id = market_id
        request.subaccount_id = subaccount_id
        request.order_hash = order_hash

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/CancelDerivativeOrder",
            request,
            MsgCancelDerivativeOrderResponse,
        )

    async def batch_cancel_derivative_orders(
        self, *, sender: str = "", data: List["OrderData"] = []
    ) -> MsgBatchCancelDerivativeOrdersResponse:
        """
        MsgBatchCancelDerivativeOrders defines a method for cancelling a batch
        of derivative limit orders.
        """

        request = MsgBatchCancelDerivativeOrders()
        request.sender = sender
        if data is not None:
            request.data = data

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/BatchCancelDerivativeOrders",
            request,
            MsgBatchCancelDerivativeOrdersResponse,
        )

    async def subaccount_transfer(
        self,
        *,
        sender: str = "",
        source_subaccount_id: str = "",
        destination_subaccount_id: str = "",
        amount: Optional[v1beta1.Coin] = None,
    ) -> MsgSubaccountTransferResponse:
        """
        SubaccountTransfer defines a method for transfer between subaccounts
        """

        request = MsgSubaccountTransfer()
        request.sender = sender
        request.source_subaccount_id = source_subaccount_id
        request.destination_subaccount_id = destination_subaccount_id
        if amount is not None:
            request.amount = amount

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/SubaccountTransfer",
            request,
            MsgSubaccountTransferResponse,
        )

    async def external_transfer(
        self,
        *,
        sender: str = "",
        source_subaccount_id: str = "",
        destination_subaccount_id: str = "",
        amount: Optional[v1beta1.Coin] = None,
    ) -> MsgExternalTransferResponse:
        """
        ExternalTransfer defines a method for transfer between external
        accounts
        """

        request = MsgExternalTransfer()
        request.sender = sender
        request.source_subaccount_id = source_subaccount_id
        request.destination_subaccount_id = destination_subaccount_id
        if amount is not None:
            request.amount = amount

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/ExternalTransfer",
            request,
            MsgExternalTransferResponse,
        )

    async def liquidate_position(
        self,
        *,
        sender: str = "",
        subaccount_id: str = "",
        market_id: str = "",
        order: Optional["DerivativeOrder"] = None,
    ) -> MsgLiquidatePositionResponse:
        """LiquidatePosition defines a method for liquidating a position"""

        request = MsgLiquidatePosition()
        request.sender = sender
        request.subaccount_id = subaccount_id
        request.market_id = market_id
        if order is not None:
            request.order = order

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/LiquidatePosition",
            request,
            MsgLiquidatePositionResponse,
        )

    async def increase_position_margin(
        self,
        *,
        sender: str = "",
        source_subaccount_id: str = "",
        destination_subaccount_id: str = "",
        market_id: str = "",
        amount: str = "",
    ) -> MsgIncreasePositionMarginResponse:
        """
        IncreasePositionMargin defines a method for increasing margin of a
        position
        """

        request = MsgIncreasePositionMargin()
        request.sender = sender
        request.source_subaccount_id = source_subaccount_id
        request.destination_subaccount_id = destination_subaccount_id
        request.market_id = market_id
        request.amount = amount

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Msg/IncreasePositionMargin",
            request,
            MsgIncreasePositionMarginResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query defines the gRPC querier service."""

    async def query_exchange_params(self) -> QueryExchangeParamsResponse:
        """Retrieves exchange params"""

        request = QueryExchangeParamsRequest()

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/QueryExchangeParams",
            request,
            QueryExchangeParamsResponse,
        )

    async def subaccount_deposits(
        self, *, subaccount_id: str = "", subaccount: Optional["Subaccount"] = None
    ) -> QuerySubaccountDepositsResponse:
        """Retrieves a Subaccount's Deposits"""

        request = QuerySubaccountDepositsRequest()
        request.subaccount_id = subaccount_id
        if subaccount is not None:
            request.subaccount = subaccount

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/SubaccountDeposits",
            request,
            QuerySubaccountDepositsResponse,
        )

    async def subaccount_deposit(
        self, *, subaccount_id: str = "", denom: str = ""
    ) -> QuerySubaccountDepositResponse:
        """Retrieves a Subaccount's Deposits"""

        request = QuerySubaccountDepositRequest()
        request.subaccount_id = subaccount_id
        request.denom = denom

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/SubaccountDeposit",
            request,
            QuerySubaccountDepositResponse,
        )

    async def exchange_balances(self) -> QueryExchangeBalancesResponse:
        """Retrieves all of the balances of all users on the exchange."""

        request = QueryExchangeBalancesRequest()

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/ExchangeBalances",
            request,
            QueryExchangeBalancesResponse,
        )

    async def spot_markets(self, *, status: str = "") -> QuerySpotMarketsResponse:
        """Retrieves a list of spot markets."""

        request = QuerySpotMarketsRequest()
        request.status = status

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/SpotMarkets",
            request,
            QuerySpotMarketsResponse,
        )

    async def spot_market(self, *, market_id: str = "") -> QuerySpotMarketResponse:
        """Retrieves a spot market by ticker"""

        request = QuerySpotMarketRequest()
        request.market_id = market_id

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/SpotMarket",
            request,
            QuerySpotMarketResponse,
        )

    async def spot_orderbook(
        self, *, market_id: str = "", limit: int = 0
    ) -> QuerySpotOrderbookResponse:
        """Retrieves a spot market's orderbook by marketID"""

        request = QuerySpotOrderbookRequest()
        request.market_id = market_id
        request.limit = limit

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/SpotOrderbook",
            request,
            QuerySpotOrderbookResponse,
        )

    async def trader_spot_orders(
        self, *, market_id: str = "", subaccount_id: str = ""
    ) -> QueryTraderSpotOrdersResponse:
        """Retrieves a trader's spot orders"""

        request = QueryTraderSpotOrdersRequest()
        request.market_id = market_id
        request.subaccount_id = subaccount_id

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/TraderSpotOrders",
            request,
            QueryTraderSpotOrdersResponse,
        )

    async def derivative_orderbook(
        self, *, market_id: str = "", limit: int = 0
    ) -> QueryDerivativeOrderbookResponse:
        """Retrieves a derivative market's orderbook by marketID"""

        request = QueryDerivativeOrderbookRequest()
        request.market_id = market_id
        request.limit = limit

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/DerivativeOrderbook",
            request,
            QueryDerivativeOrderbookResponse,
        )

    async def trader_derivative_orders(
        self, *, market_id: str = "", subaccount_id: str = ""
    ) -> QueryTraderDerivativeOrdersResponse:
        """Retrieves a trader's derivative orders"""

        request = QueryTraderDerivativeOrdersRequest()
        request.market_id = market_id
        request.subaccount_id = subaccount_id

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/TraderDerivativeOrders",
            request,
            QueryTraderDerivativeOrdersResponse,
        )

    async def derivative_markets(
        self, *, status: str = ""
    ) -> QueryDerivativeMarketsResponse:
        """Retrieves a list of spot markets."""

        request = QueryDerivativeMarketsRequest()
        request.status = status

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/DerivativeMarkets",
            request,
            QueryDerivativeMarketsResponse,
        )

    async def derivative_market(
        self, *, market_id: str = ""
    ) -> QueryDerivativeMarketResponse:
        """Retrieves a spot market by ticker"""

        request = QueryDerivativeMarketRequest()
        request.market_id = market_id

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/DerivativeMarket",
            request,
            QueryDerivativeMarketResponse,
        )

    async def subaccount_trade_nonce(
        self, *, subaccount_id: str = ""
    ) -> QuerySubaccountTradeNonceResponse:
        """Retrieves a subaccount's trade nonce"""

        request = QuerySubaccountTradeNonceRequest()
        request.subaccount_id = subaccount_id

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/SubaccountTradeNonce",
            request,
            QuerySubaccountTradeNonceResponse,
        )

    async def exchange_module_state(self) -> QueryModuleStateResponse:
        """Retrieves the entire exchange module's state"""

        request = QueryModuleStateRequest()

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/ExchangeModuleState",
            request,
            QueryModuleStateResponse,
        )

    async def positions(self) -> QueryPositionsResponse:
        """Retrieves the entire exchange module's positions"""

        request = QueryPositionsRequest()

        return await self._unary_unary(
            "/injective.exchange.v1beta1.Query/Positions",
            request,
            QueryPositionsResponse,
        )
