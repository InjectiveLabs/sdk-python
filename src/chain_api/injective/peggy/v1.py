# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: injective/peggy/v1/attestation.proto, injective/peggy/v1/events.proto, injective/peggy/v1/pool.proto, injective/peggy/v1/batch.proto, injective/peggy/v1/types.proto, injective/peggy/v1/msgs.proto, injective/peggy/v1/genesis.proto, injective/peggy/v1/query.proto, injective/peggy/v1/ethereum_signer.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base import v1beta1
from .google import protobuf


class ClaimType(betterproto.Enum):
    """
    ClaimType is the cosmos type of an event from the counterpart chain that
    can be handled
    """

    CLAIM_TYPE_UNKNOWN = 0
    CLAIM_TYPE_DEPOSIT = 1
    CLAIM_TYPE_WITHDRAW = 2
    CLAIM_TYPE_ERC20_DEPLOYED = 3
    CLAIM_TYPE_VALSET_UPDATED = 4


class SignType(betterproto.Enum):
    """SignType defines messages that have been signed by an orchestrator"""

    SIGN_TYPE_UNKNOWN = 0
    SIGN_TYPE_ORCHESTRATOR_SIGNED_MULTI_SIG_UPDATE = 1
    SIGN_TYPE_ORCHESTRATOR_SIGNED_WITHDRAW_BATCH = 2


@dataclass
class Attestation(betterproto.Message):
    """
    Attestation is an aggregate of `claims` that eventually becomes `observed`
    by all orchestrators EVENT_NONCE: EventNonce a nonce provided by the peggy
    contract that is unique per event fired These event nonces must be relayed
    in order. This is a correctness issue, if relaying out of order transaction
    replay attacks become possible OBSERVED: Observed indicates that >67% of
    validators have attested to the event, and that the event should be
    executed by the peggy state machine The actual content of the claims is
    passed in with the transaction making the claim and then passed through the
    call stack alongside the attestation while it is processed the key in which
    the attestation is stored is keyed on the exact details of the claim but
    there is no reason to store those exact details becuause the next message
    sender will kindly provide you with them.
    """

    observed: bool = betterproto.bool_field(1)
    votes: List[str] = betterproto.string_field(2)
    height: int = betterproto.uint64_field(3)
    claim: protobuf.Any = betterproto.message_field(4)


@dataclass
class ERC20Token(betterproto.Message):
    """
    ERC20Token unique identifier for an Ethereum ERC20 token. CONTRACT: The
    contract address on ETH of the token, this could be a Cosmos originated
    token, if so it will be the ERC20 address of the representation (note:
    developers should look up the token symbol using the address on ETH to
    display for UI)
    """

    contract: str = betterproto.string_field(1)
    amount: str = betterproto.string_field(2)


@dataclass
class EventAttestationObserved(betterproto.Message):
    attestation_type: "ClaimType" = betterproto.enum_field(1)
    bridge_contract: str = betterproto.string_field(2)
    bridge_chain_id: int = betterproto.uint64_field(3)
    attestation_id: bytes = betterproto.bytes_field(4)
    nonce: int = betterproto.uint64_field(5)


@dataclass
class EventBridgeWithdrawCanceled(betterproto.Message):
    bridge_contract: str = betterproto.string_field(1)
    bridge_chain_id: int = betterproto.uint64_field(2)


@dataclass
class EventBridgeWithdrawalReceived(betterproto.Message):
    bridge_contract: str = betterproto.string_field(1)
    bridge_chain_id: int = betterproto.uint64_field(2)
    outgoing_tx_id: int = betterproto.uint64_field(3)
    nonce: int = betterproto.uint64_field(4)


@dataclass
class EventOutgoingBatch(betterproto.Message):
    bridge_contract: str = betterproto.string_field(1)
    bridge_chain_id: int = betterproto.uint64_field(2)
    batch_id: int = betterproto.uint64_field(3)
    nonce: int = betterproto.uint64_field(4)


@dataclass
class EventOutgoingBatchCanceled(betterproto.Message):
    bridge_contract: str = betterproto.string_field(1)
    bridge_chain_id: int = betterproto.uint64_field(2)
    batch_id: int = betterproto.uint64_field(3)
    nonce: int = betterproto.uint64_field(4)


@dataclass
class EventMultisigUpdateRequest(betterproto.Message):
    bridge_contract: str = betterproto.string_field(1)
    bridge_chain_id: int = betterproto.uint64_field(2)
    multisig_id: int = betterproto.uint64_field(3)
    nonce: int = betterproto.uint64_field(4)


@dataclass
class EventSetOrchestratorAddresses(betterproto.Message):
    set_operator_address: bytes = betterproto.bytes_field(1)


@dataclass
class EventValsetConfirm(betterproto.Message):
    valset_confirm_key: bytes = betterproto.bytes_field(1)


@dataclass
class EventSendToEth(betterproto.Message):
    outgoing_tx_id: int = betterproto.uint64_field(1)


@dataclass
class EventRequestBatch(betterproto.Message):
    batch_nonce: int = betterproto.uint64_field(1)


@dataclass
class EventConfirmBatch(betterproto.Message):
    batch_confirm_key: bytes = betterproto.bytes_field(1)


@dataclass
class EventDepositClaim(betterproto.Message):
    attestation_id: bytes = betterproto.bytes_field(1)


@dataclass
class EventWithdrawClaim(betterproto.Message):
    attestation_id: bytes = betterproto.bytes_field(1)


@dataclass
class EventERC20DeployedClaim(betterproto.Message):
    attestation_id: bytes = betterproto.bytes_field(1)


@dataclass
class EventValsetUpdateClaim(betterproto.Message):
    attestation_id: bytes = betterproto.bytes_field(1)


@dataclass
class EventCancelSendToEth(betterproto.Message):
    outgoing_tx_id: int = betterproto.uint64_field(1)


@dataclass
class EventSubmitBadSignatureEvidence(betterproto.Message):
    bad_eth_signature: str = betterproto.string_field(1)
    bad_eth_signature_subject: str = betterproto.string_field(2)


@dataclass
class IDSet(betterproto.Message):
    """IDSet represents a set of IDs"""

    ids: List[int] = betterproto.uint64_field(1)


@dataclass
class BatchFees(betterproto.Message):
    token: str = betterproto.string_field(1)
    total_fees: str = betterproto.string_field(2)


@dataclass
class OutgoingTxBatch(betterproto.Message):
    """
    OutgoingTxBatch represents a batch of transactions going from Peggy to ETH
    """

    batch_nonce: int = betterproto.uint64_field(1)
    batch_timeout: int = betterproto.uint64_field(2)
    transactions: List["OutgoingTransferTx"] = betterproto.message_field(3)
    token_contract: str = betterproto.string_field(4)
    block: int = betterproto.uint64_field(5)


@dataclass
class OutgoingTransferTx(betterproto.Message):
    """OutgoingTransferTx represents an individual send from Peggy to ETH"""

    id: int = betterproto.uint64_field(1)
    sender: str = betterproto.string_field(2)
    dest_address: str = betterproto.string_field(3)
    erc20_token: "ERC20Token" = betterproto.message_field(4)
    erc20_fee: "ERC20Token" = betterproto.message_field(5)


@dataclass
class BridgeValidator(betterproto.Message):
    """BridgeValidator represents a validator's ETH address and its power"""

    power: int = betterproto.uint64_field(1)
    ethereum_address: str = betterproto.string_field(2)


@dataclass
class Valset(betterproto.Message):
    """
    Valset is the Ethereum Bridge Multsig Set, each peggy validator also
    maintains an ETH key to sign messages, these are used to check signatures
    on ETH because of the significant gas savings
    """

    nonce: int = betterproto.uint64_field(1)
    members: List["BridgeValidator"] = betterproto.message_field(2)
    height: int = betterproto.uint64_field(3)
    reward_amount: str = betterproto.string_field(4)
    # the reward token in it's Ethereum hex address representation
    reward_token: str = betterproto.string_field(5)


@dataclass
class LastObservedEthereumBlockHeight(betterproto.Message):
    """
    LastObservedEthereumBlockHeight stores the last observed Ethereum block
    height along with the Cosmos block height that it was observed at. These
    two numbers can be used to project outward and always produce batches with
    timeouts in the future even if no Ethereum block height has been relayed
    for a long time
    """

    cosmos_block_height: int = betterproto.uint64_field(1)
    ethereum_block_height: int = betterproto.uint64_field(2)


@dataclass
class LastClaimEvent(betterproto.Message):
    """LastClaimEvent stores last claim event details of validator."""

    ethereum_event_nonce: int = betterproto.uint64_field(1)
    ethereum_event_height: int = betterproto.uint64_field(2)


@dataclass
class ERC20ToDenom(betterproto.Message):
    """
    This records the relationship between an ERC20 token and the denom of the
    corresponding Cosmos originated asset
    """

    erc20: str = betterproto.string_field(1)
    denom: str = betterproto.string_field(2)


@dataclass
class MsgSetOrchestratorAddresses(betterproto.Message):
    """
    MsgSetOrchestratorAddresses this message allows validators to delegate
    their voting responsibilities  to a given key. This key is then used as an
    optional authentication method for sigining oracle claims VALIDATOR The
    validator field is a cosmosvaloper1... string (i.e. sdk.ValAddress) that
    references a validator in the active set ORCHESTRATOR The orchestrator
    field is a cosmos1... string  (i.e. sdk.AccAddress) that  references the
    key that is being delegated to ETH_ADDRESS This is a hex encoded 0x
    Ethereum public key that will be used by this validator on Ethereum
    """

    sender: str = betterproto.string_field(1)
    orchestrator: str = betterproto.string_field(2)
    eth_address: str = betterproto.string_field(3)


@dataclass
class MsgSetOrchestratorAddressesResponse(betterproto.Message):
    pass


@dataclass
class MsgValsetConfirm(betterproto.Message):
    """
    MsgValsetConfirm this is the message sent by the validators when they wish
    to submit their signatures over the validator set at a given block height.
    A validator must first call MsgSetEthAddress to set their Ethereum address
    to be used for signing. Then someone (anyone) must make a ValsetRequest the
    request is essentially a messaging mechanism to determine which block all
    validators should submit signatures over. Finally validators sign the
    validator set, powers, and Ethereum addresses of the entire validator set
    at the height of a ValsetRequest and submit that signature with this
    message. If a sufficient number of validators (66% of voting power) (A)
    have set Ethereum addresses and (B) submit ValsetConfirm messages with
    their signatures it is then possible for anyone to view these signatures in
    the chain store and submit them to Ethereum to update the validator set
    -------------
    """

    nonce: int = betterproto.uint64_field(1)
    orchestrator: str = betterproto.string_field(2)
    eth_address: str = betterproto.string_field(3)
    signature: str = betterproto.string_field(4)


@dataclass
class MsgValsetConfirmResponse(betterproto.Message):
    pass


@dataclass
class MsgSendToEth(betterproto.Message):
    """
    MsgSendToEth This is the message that a user calls when they want to bridge
    an asset it will later be removed when it is included in a batch and
    successfully submitted tokens are removed from the users balance
    immediately ------------- AMOUNT: the coin to send across the bridge, note
    the restriction that this is a single coin not a set of coins that is
    normal in other Cosmos messages FEE: the fee paid for the bridge, distinct
    from the fee paid to the chain to actually send this message in the first
    place. So a successful send has two layers of fees for the user
    """

    sender: str = betterproto.string_field(1)
    eth_dest: str = betterproto.string_field(2)
    amount: v1beta1.Coin = betterproto.message_field(3)
    bridge_fee: v1beta1.Coin = betterproto.message_field(4)


@dataclass
class MsgSendToEthResponse(betterproto.Message):
    pass


@dataclass
class MsgRequestBatch(betterproto.Message):
    """
    MsgRequestBatch this is a message anyone can send that requests a batch of
    transactions to send across the bridge be created for whatever block height
    this message is included in. This acts as a coordination point, the handler
    for this message looks at the AddToOutgoingPool tx's in the store and
    generates a batch, also available in the store tied to this message. The
    validators then grab this batch, sign it, submit the signatures with a
    MsgConfirmBatch before a relayer can finally submit the batch -------------
    """

    orchestrator: str = betterproto.string_field(1)
    denom: str = betterproto.string_field(2)


@dataclass
class MsgRequestBatchResponse(betterproto.Message):
    pass


@dataclass
class MsgConfirmBatch(betterproto.Message):
    """
    MsgConfirmBatch When validators observe a MsgRequestBatch they form a batch
    by ordering transactions currently in the txqueue in order of highest to
    lowest fee, cutting off when the batch either reaches a hardcoded maximum
    size (to be decided, probably around 100) or when transactions stop being
    profitable (TODO determine this without nondeterminism) This message
    includes the batch as well as an Ethereum signature over this batch by the
    validator -------------
    """

    nonce: int = betterproto.uint64_field(1)
    token_contract: str = betterproto.string_field(2)
    eth_signer: str = betterproto.string_field(3)
    orchestrator: str = betterproto.string_field(4)
    signature: str = betterproto.string_field(5)


@dataclass
class MsgConfirmBatchResponse(betterproto.Message):
    pass


@dataclass
class MsgDepositClaim(betterproto.Message):
    """
    EthereumBridgeDepositClaim When more than 66% of the active validator set
    has claimed to have seen the deposit enter the ethereum blockchain coins
    are issued to the Cosmos address in question -------------
    """

    event_nonce: int = betterproto.uint64_field(1)
    block_height: int = betterproto.uint64_field(2)
    token_contract: str = betterproto.string_field(3)
    amount: str = betterproto.string_field(4)
    ethereum_sender: str = betterproto.string_field(5)
    cosmos_receiver: str = betterproto.string_field(6)
    orchestrator: str = betterproto.string_field(7)


@dataclass
class MsgDepositClaimResponse(betterproto.Message):
    pass


@dataclass
class MsgWithdrawClaim(betterproto.Message):
    """
    WithdrawClaim claims that a batch of withdrawal operations on the bridge
    contract was executed.
    """

    event_nonce: int = betterproto.uint64_field(1)
    block_height: int = betterproto.uint64_field(2)
    batch_nonce: int = betterproto.uint64_field(3)
    token_contract: str = betterproto.string_field(4)
    orchestrator: str = betterproto.string_field(5)


@dataclass
class MsgWithdrawClaimResponse(betterproto.Message):
    pass


@dataclass
class MsgERC20DeployedClaim(betterproto.Message):
    """
    ERC20DeployedClaim allows the Cosmos module to learn about an ERC20 that
    someone deployed to represent a Cosmos asset
    """

    event_nonce: int = betterproto.uint64_field(1)
    block_height: int = betterproto.uint64_field(2)
    cosmos_denom: str = betterproto.string_field(3)
    token_contract: str = betterproto.string_field(4)
    name: str = betterproto.string_field(5)
    symbol: str = betterproto.string_field(6)
    decimals: int = betterproto.uint64_field(7)
    orchestrator: str = betterproto.string_field(8)


@dataclass
class MsgERC20DeployedClaimResponse(betterproto.Message):
    pass


@dataclass
class MsgCancelSendToEth(betterproto.Message):
    """
    This call allows the sender (and only the sender) to cancel a given
    MsgSendToEth and recieve a refund of the tokens
    """

    transaction_id: int = betterproto.uint64_field(1)
    sender: str = betterproto.string_field(2)


@dataclass
class MsgCancelSendToEthResponse(betterproto.Message):
    pass


@dataclass
class MsgSubmitBadSignatureEvidence(betterproto.Message):
    """
    This call allows anyone to submit evidence that a validator has signed a
    valset, batch, or logic call that never existed. Subject contains the
    batch, valset, or logic call.
    """

    subject: protobuf.Any = betterproto.message_field(1)
    signature: str = betterproto.string_field(2)
    sender: str = betterproto.string_field(3)


@dataclass
class MsgSubmitBadSignatureEvidenceResponse(betterproto.Message):
    pass


@dataclass
class MsgValsetUpdatedClaim(betterproto.Message):
    """
    This informs the Cosmos module that a validator set has been updated.
    """

    event_nonce: int = betterproto.uint64_field(1)
    valset_nonce: int = betterproto.uint64_field(2)
    block_height: int = betterproto.uint64_field(3)
    members: List["BridgeValidator"] = betterproto.message_field(4)
    reward_amount: str = betterproto.string_field(5)
    reward_token: str = betterproto.string_field(6)
    orchestrator: str = betterproto.string_field(7)


@dataclass
class MsgValsetUpdatedClaimResponse(betterproto.Message):
    pass


@dataclass
class Params(betterproto.Message):
    """
    Params represent the peggy genesis and store parameters peggy_id: a random
    32 byte value to prevent signature reuse, for example if the cosmos
    validators decided to use the same Ethereum keys for another chain also
    running Peggy we would not want it to be possible to play a deposit from
    chain A back on chain B's peggy. This value IS USED ON ETHEREUM so it must
    be set in your genesis.json before launch and not changed after deploying
    Peggy contract_hash: the code hash of a known good version of the Peggy
    contract solidity code. This can be used to verify the correct version of
    the contract has been deployed. This is a reference value for goernance
    action only it is never read by any Peggy code bridge_ethereum_address: is
    address of the bridge contract on the Ethereum side, this is a reference
    value for governance only and is not actually used by any Peggy code
    bridge_chain_id: the unique identifier of the Ethereum chain, this is a
    reference value only and is not actually used by any Peggy code These
    reference values may be used by future Peggy client implemetnations to
    allow for saftey features or convenience features like the peggy address in
    your relayer. A relayer would require a configured peggy address if
    governance had not set the address on the chain it was relaying for.
    signed_valsets_window signed_batches_window signed_claims_window These
    values represent the time in blocks that a validator has to submit a
    signature for a batch or valset, or to submit a claim for a particular
    attestation nonce. In the case of attestations this clock starts when the
    attestation is created, but only allows for slashing once the event has
    passed target_batch_timeout: This is the 'target' value for when batches
    time out, this is a target becuase Ethereum is a probabalistic chain and
    you can't say for sure what the block frequency is ahead of time.
    average_block_time average_ethereum_block_time These values are the average
    Cosmos block time and Ethereum block time repsectively and they are used to
    copute what the target batch timeout is. It is important that governance
    updates these in case of any major, prolonged change in the time it takes
    to produce a block slash_fraction_valset slash_fraction_batch
    slash_fraction_claim slash_fraction_conflicting_claim The slashing
    fractions for the various peggy related slashing conditions. The first
    three refer to not submitting a particular message, the third for
    submitting a different claim for the same Ethereum event
    unbond_slashing_valsets_window The unbond slashing valsets window is used
    to determine how many blocks after starting to unbond a validator needs to
    continue signing blocks. The goal of this paramater is that when a
    validator leaves the set, if their leaving creates enough change in the
    validator set to justify an update they will sign a validator set update
    for the Ethereum bridge that does not include themselves. Allowing us to
    remove them from the Ethereum bridge and replace them with the new set
    gracefully. valset_reward Valset rewards are the amount of tokens this
    chain issues to relayers of validator sets. These can be any ERC20 token in
    the bridge, but it's strongly advised that chains use only Cosmos
    originated tokens, which the bridge effectively mints on Ethereum. If you
    run out of the token you are using for validator set rewards valset updates
    will fail and the bridge will be vulnerable to highjacking. For these
    paramaters the zero values are special and indicate not to attempt any
    reward. This is the default for bootstrapping.
    """

    peggy_id: str = betterproto.string_field(1)
    contract_source_hash: str = betterproto.string_field(2)
    bridge_ethereum_address: str = betterproto.string_field(3)
    bridge_chain_id: int = betterproto.uint64_field(4)
    signed_valsets_window: int = betterproto.uint64_field(5)
    signed_batches_window: int = betterproto.uint64_field(6)
    signed_claims_window: int = betterproto.uint64_field(7)
    target_batch_timeout: int = betterproto.uint64_field(8)
    average_block_time: int = betterproto.uint64_field(9)
    average_ethereum_block_time: int = betterproto.uint64_field(10)
    slash_fraction_valset: bytes = betterproto.bytes_field(11)
    slash_fraction_batch: bytes = betterproto.bytes_field(12)
    slash_fraction_claim: bytes = betterproto.bytes_field(13)
    slash_fraction_conflicting_claim: bytes = betterproto.bytes_field(14)
    unbond_slashing_valsets_window: int = betterproto.uint64_field(15)
    slash_fraction_bad_eth_signature: bytes = betterproto.bytes_field(16)
    cosmos_coin_denom: str = betterproto.string_field(17)
    cosmos_coin_erc20_contract: str = betterproto.string_field(18)
    claim_slashing_enabled: bool = betterproto.bool_field(19)
    bridge_contract_start_height: int = betterproto.uint64_field(20)
    valset_reward: v1beta1.Coin = betterproto.message_field(21)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState struct"""

    params: "Params" = betterproto.message_field(1)
    last_observed_nonce: int = betterproto.uint64_field(2)
    valsets: List["Valset"] = betterproto.message_field(3)
    valset_confirms: List["MsgValsetConfirm"] = betterproto.message_field(4)
    batches: List["OutgoingTxBatch"] = betterproto.message_field(5)
    batch_confirms: List["MsgConfirmBatch"] = betterproto.message_field(6)
    attestations: List["Attestation"] = betterproto.message_field(7)
    orchestrator_addresses: List[
        "MsgSetOrchestratorAddresses"
    ] = betterproto.message_field(8)
    erc20_to_denoms: List["ERC20ToDenom"] = betterproto.message_field(9)
    unbatched_transfers: List["OutgoingTransferTx"] = betterproto.message_field(10)
    last_observed_ethereum_height: int = betterproto.uint64_field(11)
    last_outgoing_batch_id: int = betterproto.uint64_field(12)
    last_outgoing_pool_id: int = betterproto.uint64_field(13)
    last_observed_valset: "Valset" = betterproto.message_field(14)


@dataclass
class QueryParamsRequest(betterproto.Message):
    pass


@dataclass
class QueryParamsResponse(betterproto.Message):
    params: "Params" = betterproto.message_field(1)


@dataclass
class QueryCurrentValsetRequest(betterproto.Message):
    pass


@dataclass
class QueryCurrentValsetResponse(betterproto.Message):
    valset: "Valset" = betterproto.message_field(1)


@dataclass
class QueryValsetRequestRequest(betterproto.Message):
    nonce: int = betterproto.uint64_field(1)


@dataclass
class QueryValsetRequestResponse(betterproto.Message):
    valset: "Valset" = betterproto.message_field(1)


@dataclass
class QueryValsetConfirmRequest(betterproto.Message):
    nonce: int = betterproto.uint64_field(1)
    address: str = betterproto.string_field(2)


@dataclass
class QueryValsetConfirmResponse(betterproto.Message):
    confirm: "MsgValsetConfirm" = betterproto.message_field(1)


@dataclass
class QueryValsetConfirmsByNonceRequest(betterproto.Message):
    nonce: int = betterproto.uint64_field(1)


@dataclass
class QueryValsetConfirmsByNonceResponse(betterproto.Message):
    confirms: List["MsgValsetConfirm"] = betterproto.message_field(1)


@dataclass
class QueryLastValsetRequestsRequest(betterproto.Message):
    pass


@dataclass
class QueryLastValsetRequestsResponse(betterproto.Message):
    valsets: List["Valset"] = betterproto.message_field(1)


@dataclass
class QueryLastPendingValsetRequestByAddrRequest(betterproto.Message):
    address: str = betterproto.string_field(1)


@dataclass
class QueryLastPendingValsetRequestByAddrResponse(betterproto.Message):
    valsets: List["Valset"] = betterproto.message_field(1)


@dataclass
class QueryBatchFeeRequest(betterproto.Message):
    pass


@dataclass
class QueryBatchFeeResponse(betterproto.Message):
    batch_fees: List["BatchFees"] = betterproto.message_field(1)


@dataclass
class QueryLastPendingBatchRequestByAddrRequest(betterproto.Message):
    address: str = betterproto.string_field(1)


@dataclass
class QueryLastPendingBatchRequestByAddrResponse(betterproto.Message):
    batch: "OutgoingTxBatch" = betterproto.message_field(1)


@dataclass
class QueryOutgoingTxBatchesRequest(betterproto.Message):
    pass


@dataclass
class QueryOutgoingTxBatchesResponse(betterproto.Message):
    batches: List["OutgoingTxBatch"] = betterproto.message_field(1)


@dataclass
class QueryBatchRequestByNonceRequest(betterproto.Message):
    nonce: int = betterproto.uint64_field(1)
    contract_address: str = betterproto.string_field(2)


@dataclass
class QueryBatchRequestByNonceResponse(betterproto.Message):
    batch: "OutgoingTxBatch" = betterproto.message_field(1)


@dataclass
class QueryBatchConfirmsRequest(betterproto.Message):
    nonce: int = betterproto.uint64_field(1)
    contract_address: str = betterproto.string_field(2)


@dataclass
class QueryBatchConfirmsResponse(betterproto.Message):
    confirms: List["MsgConfirmBatch"] = betterproto.message_field(1)


@dataclass
class QueryLastEventByAddrRequest(betterproto.Message):
    address: str = betterproto.string_field(1)


@dataclass
class QueryLastEventByAddrResponse(betterproto.Message):
    last_claim_event: "LastClaimEvent" = betterproto.message_field(1)


@dataclass
class QueryERC20ToDenomRequest(betterproto.Message):
    erc20: str = betterproto.string_field(1)


@dataclass
class QueryERC20ToDenomResponse(betterproto.Message):
    denom: str = betterproto.string_field(1)
    cosmos_originated: bool = betterproto.bool_field(2)


@dataclass
class QueryDenomToERC20Request(betterproto.Message):
    denom: str = betterproto.string_field(1)


@dataclass
class QueryDenomToERC20Response(betterproto.Message):
    erc20: str = betterproto.string_field(1)
    cosmos_originated: bool = betterproto.bool_field(2)


@dataclass
class QueryDelegateKeysByValidatorAddress(betterproto.Message):
    validator_address: str = betterproto.string_field(1)


@dataclass
class QueryDelegateKeysByValidatorAddressResponse(betterproto.Message):
    eth_address: str = betterproto.string_field(1)
    orchestrator_address: str = betterproto.string_field(2)


@dataclass
class QueryDelegateKeysByEthAddress(betterproto.Message):
    eth_address: str = betterproto.string_field(1)


@dataclass
class QueryDelegateKeysByEthAddressResponse(betterproto.Message):
    validator_address: str = betterproto.string_field(1)
    orchestrator_address: str = betterproto.string_field(2)


@dataclass
class QueryDelegateKeysByOrchestratorAddress(betterproto.Message):
    orchestrator_address: str = betterproto.string_field(1)


@dataclass
class QueryDelegateKeysByOrchestratorAddressResponse(betterproto.Message):
    validator_address: str = betterproto.string_field(1)
    eth_address: str = betterproto.string_field(2)


@dataclass
class QueryPendingSendToEth(betterproto.Message):
    sender_address: str = betterproto.string_field(1)


@dataclass
class QueryPendingSendToEthResponse(betterproto.Message):
    transfers_in_batches: List["OutgoingTransferTx"] = betterproto.message_field(1)
    unbatched_transfers: List["OutgoingTransferTx"] = betterproto.message_field(2)


@dataclass
class QueryModuleStateRequest(betterproto.Message):
    """
    QueryModuleStateRequest is the request type for the Query/PeggyModuleState
    RPC method.
    """

    pass


@dataclass
class QueryModuleStateResponse(betterproto.Message):
    """
    QueryModuleStateResponse is the response type for the
    Query/PeggyModuleState RPC method.
    """

    state: "GenesisState" = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    async def valset_confirm(
        self,
        *,
        nonce: int = 0,
        orchestrator: str = "",
        eth_address: str = "",
        signature: str = "",
    ) -> MsgValsetConfirmResponse:
        request = MsgValsetConfirm()
        request.nonce = nonce
        request.orchestrator = orchestrator
        request.eth_address = eth_address
        request.signature = signature

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/ValsetConfirm",
            request,
            MsgValsetConfirmResponse,
        )

    async def send_to_eth(
        self,
        *,
        sender: str = "",
        eth_dest: str = "",
        amount: Optional[v1beta1.Coin] = None,
        bridge_fee: Optional[v1beta1.Coin] = None,
    ) -> MsgSendToEthResponse:
        request = MsgSendToEth()
        request.sender = sender
        request.eth_dest = eth_dest
        if amount is not None:
            request.amount = amount
        if bridge_fee is not None:
            request.bridge_fee = bridge_fee

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/SendToEth",
            request,
            MsgSendToEthResponse,
        )

    async def request_batch(
        self, *, orchestrator: str = "", denom: str = ""
    ) -> MsgRequestBatchResponse:
        request = MsgRequestBatch()
        request.orchestrator = orchestrator
        request.denom = denom

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/RequestBatch",
            request,
            MsgRequestBatchResponse,
        )

    async def confirm_batch(
        self,
        *,
        nonce: int = 0,
        token_contract: str = "",
        eth_signer: str = "",
        orchestrator: str = "",
        signature: str = "",
    ) -> MsgConfirmBatchResponse:
        request = MsgConfirmBatch()
        request.nonce = nonce
        request.token_contract = token_contract
        request.eth_signer = eth_signer
        request.orchestrator = orchestrator
        request.signature = signature

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/ConfirmBatch",
            request,
            MsgConfirmBatchResponse,
        )

    async def deposit_claim(
        self,
        *,
        event_nonce: int = 0,
        block_height: int = 0,
        token_contract: str = "",
        amount: str = "",
        ethereum_sender: str = "",
        cosmos_receiver: str = "",
        orchestrator: str = "",
    ) -> MsgDepositClaimResponse:
        request = MsgDepositClaim()
        request.event_nonce = event_nonce
        request.block_height = block_height
        request.token_contract = token_contract
        request.amount = amount
        request.ethereum_sender = ethereum_sender
        request.cosmos_receiver = cosmos_receiver
        request.orchestrator = orchestrator

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/DepositClaim",
            request,
            MsgDepositClaimResponse,
        )

    async def withdraw_claim(
        self,
        *,
        event_nonce: int = 0,
        block_height: int = 0,
        batch_nonce: int = 0,
        token_contract: str = "",
        orchestrator: str = "",
    ) -> MsgWithdrawClaimResponse:
        request = MsgWithdrawClaim()
        request.event_nonce = event_nonce
        request.block_height = block_height
        request.batch_nonce = batch_nonce
        request.token_contract = token_contract
        request.orchestrator = orchestrator

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/WithdrawClaim",
            request,
            MsgWithdrawClaimResponse,
        )

    async def valset_update_claim(
        self,
        *,
        event_nonce: int = 0,
        valset_nonce: int = 0,
        block_height: int = 0,
        members: List["BridgeValidator"] = [],
        reward_amount: str = "",
        reward_token: str = "",
        orchestrator: str = "",
    ) -> MsgValsetUpdatedClaimResponse:
        request = MsgValsetUpdatedClaim()
        request.event_nonce = event_nonce
        request.valset_nonce = valset_nonce
        request.block_height = block_height
        if members is not None:
            request.members = members
        request.reward_amount = reward_amount
        request.reward_token = reward_token
        request.orchestrator = orchestrator

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/ValsetUpdateClaim",
            request,
            MsgValsetUpdatedClaimResponse,
        )

    async def e_r_c20_deployed_claim(
        self,
        *,
        event_nonce: int = 0,
        block_height: int = 0,
        cosmos_denom: str = "",
        token_contract: str = "",
        name: str = "",
        symbol: str = "",
        decimals: int = 0,
        orchestrator: str = "",
    ) -> MsgERC20DeployedClaimResponse:
        request = MsgERC20DeployedClaim()
        request.event_nonce = event_nonce
        request.block_height = block_height
        request.cosmos_denom = cosmos_denom
        request.token_contract = token_contract
        request.name = name
        request.symbol = symbol
        request.decimals = decimals
        request.orchestrator = orchestrator

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/ERC20DeployedClaim",
            request,
            MsgERC20DeployedClaimResponse,
        )

    async def set_orchestrator_addresses(
        self, *, sender: str = "", orchestrator: str = "", eth_address: str = ""
    ) -> MsgSetOrchestratorAddressesResponse:
        request = MsgSetOrchestratorAddresses()
        request.sender = sender
        request.orchestrator = orchestrator
        request.eth_address = eth_address

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/SetOrchestratorAddresses",
            request,
            MsgSetOrchestratorAddressesResponse,
        )

    async def cancel_send_to_eth(
        self, *, transaction_id: int = 0, sender: str = ""
    ) -> MsgCancelSendToEthResponse:
        request = MsgCancelSendToEth()
        request.transaction_id = transaction_id
        request.sender = sender

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/CancelSendToEth",
            request,
            MsgCancelSendToEthResponse,
        )

    async def submit_bad_signature_evidence(
        self,
        *,
        subject: Optional[protobuf.Any] = None,
        signature: str = "",
        sender: str = "",
    ) -> MsgSubmitBadSignatureEvidenceResponse:
        request = MsgSubmitBadSignatureEvidence()
        if subject is not None:
            request.subject = subject
        request.signature = signature
        request.sender = sender

        return await self._unary_unary(
            "/injective.peggy.v1.Msg/SubmitBadSignatureEvidence",
            request,
            MsgSubmitBadSignatureEvidenceResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query defines the gRPC querier service"""

    async def params(self) -> QueryParamsResponse:
        """Deployments queries deployments"""

        request = QueryParamsRequest()

        return await self._unary_unary(
            "/injective.peggy.v1.Query/Params",
            request,
            QueryParamsResponse,
        )

    async def current_valset(self) -> QueryCurrentValsetResponse:
        """valset"""

        request = QueryCurrentValsetRequest()

        return await self._unary_unary(
            "/injective.peggy.v1.Query/CurrentValset",
            request,
            QueryCurrentValsetResponse,
        )

    async def valset_request(self, *, nonce: int = 0) -> QueryValsetRequestResponse:
        request = QueryValsetRequestRequest()
        request.nonce = nonce

        return await self._unary_unary(
            "/injective.peggy.v1.Query/ValsetRequest",
            request,
            QueryValsetRequestResponse,
        )

    async def valset_confirm(
        self, *, nonce: int = 0, address: str = ""
    ) -> QueryValsetConfirmResponse:
        request = QueryValsetConfirmRequest()
        request.nonce = nonce
        request.address = address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/ValsetConfirm",
            request,
            QueryValsetConfirmResponse,
        )

    async def valset_confirms_by_nonce(
        self, *, nonce: int = 0
    ) -> QueryValsetConfirmsByNonceResponse:
        request = QueryValsetConfirmsByNonceRequest()
        request.nonce = nonce

        return await self._unary_unary(
            "/injective.peggy.v1.Query/ValsetConfirmsByNonce",
            request,
            QueryValsetConfirmsByNonceResponse,
        )

    async def last_valset_requests(self) -> QueryLastValsetRequestsResponse:
        request = QueryLastValsetRequestsRequest()

        return await self._unary_unary(
            "/injective.peggy.v1.Query/LastValsetRequests",
            request,
            QueryLastValsetRequestsResponse,
        )

    async def last_pending_valset_request_by_addr(
        self, *, address: str = ""
    ) -> QueryLastPendingValsetRequestByAddrResponse:
        request = QueryLastPendingValsetRequestByAddrRequest()
        request.address = address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/LastPendingValsetRequestByAddr",
            request,
            QueryLastPendingValsetRequestByAddrResponse,
        )

    async def last_event_by_addr(
        self, *, address: str = ""
    ) -> QueryLastEventByAddrResponse:
        """claim"""

        request = QueryLastEventByAddrRequest()
        request.address = address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/LastEventByAddr",
            request,
            QueryLastEventByAddrResponse,
        )

    async def get_pending_send_to_eth(
        self, *, sender_address: str = ""
    ) -> QueryPendingSendToEthResponse:
        """batch"""

        request = QueryPendingSendToEth()
        request.sender_address = sender_address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/GetPendingSendToEth",
            request,
            QueryPendingSendToEthResponse,
        )

    async def batch_fees(self) -> QueryBatchFeeResponse:
        request = QueryBatchFeeRequest()

        return await self._unary_unary(
            "/injective.peggy.v1.Query/BatchFees",
            request,
            QueryBatchFeeResponse,
        )

    async def outgoing_tx_batches(self) -> QueryOutgoingTxBatchesResponse:
        request = QueryOutgoingTxBatchesRequest()

        return await self._unary_unary(
            "/injective.peggy.v1.Query/OutgoingTxBatches",
            request,
            QueryOutgoingTxBatchesResponse,
        )

    async def last_pending_batch_request_by_addr(
        self, *, address: str = ""
    ) -> QueryLastPendingBatchRequestByAddrResponse:
        request = QueryLastPendingBatchRequestByAddrRequest()
        request.address = address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/LastPendingBatchRequestByAddr",
            request,
            QueryLastPendingBatchRequestByAddrResponse,
        )

    async def batch_request_by_nonce(
        self, *, nonce: int = 0, contract_address: str = ""
    ) -> QueryBatchRequestByNonceResponse:
        request = QueryBatchRequestByNonceRequest()
        request.nonce = nonce
        request.contract_address = contract_address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/BatchRequestByNonce",
            request,
            QueryBatchRequestByNonceResponse,
        )

    async def batch_confirms(
        self, *, nonce: int = 0, contract_address: str = ""
    ) -> QueryBatchConfirmsResponse:
        request = QueryBatchConfirmsRequest()
        request.nonce = nonce
        request.contract_address = contract_address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/BatchConfirms",
            request,
            QueryBatchConfirmsResponse,
        )

    async def e_r_c20_to_denom(self, *, erc20: str = "") -> QueryERC20ToDenomResponse:
        request = QueryERC20ToDenomRequest()
        request.erc20 = erc20

        return await self._unary_unary(
            "/injective.peggy.v1.Query/ERC20ToDenom",
            request,
            QueryERC20ToDenomResponse,
        )

    async def denom_to_e_r_c20(self, *, denom: str = "") -> QueryDenomToERC20Response:
        request = QueryDenomToERC20Request()
        request.denom = denom

        return await self._unary_unary(
            "/injective.peggy.v1.Query/DenomToERC20",
            request,
            QueryDenomToERC20Response,
        )

    async def get_delegate_key_by_validator(
        self, *, validator_address: str = ""
    ) -> QueryDelegateKeysByValidatorAddressResponse:
        request = QueryDelegateKeysByValidatorAddress()
        request.validator_address = validator_address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/GetDelegateKeyByValidator",
            request,
            QueryDelegateKeysByValidatorAddressResponse,
        )

    async def get_delegate_key_by_eth(
        self, *, eth_address: str = ""
    ) -> QueryDelegateKeysByEthAddressResponse:
        request = QueryDelegateKeysByEthAddress()
        request.eth_address = eth_address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/GetDelegateKeyByEth",
            request,
            QueryDelegateKeysByEthAddressResponse,
        )

    async def get_delegate_key_by_orchestrator(
        self, *, orchestrator_address: str = ""
    ) -> QueryDelegateKeysByOrchestratorAddressResponse:
        request = QueryDelegateKeysByOrchestratorAddress()
        request.orchestrator_address = orchestrator_address

        return await self._unary_unary(
            "/injective.peggy.v1.Query/GetDelegateKeyByOrchestrator",
            request,
            QueryDelegateKeysByOrchestratorAddressResponse,
        )

    async def peggy_module_state(self) -> QueryModuleStateResponse:
        """Retrieves the entire peggy module's state"""

        request = QueryModuleStateRequest()

        return await self._unary_unary(
            "/injective.peggy.v1.Query/PeggyModuleState",
            request,
            QueryModuleStateResponse,
        )
