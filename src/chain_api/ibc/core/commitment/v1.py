# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ibc/core/commitment/v1/commitment.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto

from .tendermint import crypto


class KeyEncoding(betterproto.Enum):
    """KeyEncoding defines the encoding format of a key's bytes."""

    # URL encoding
    KEY_ENCODING_URL_UNSPECIFIED = 0
    # Hex encoding
    KEY_ENCODING_HEX = 1


@dataclass
class MerkleRoot(betterproto.Message):
    """
    MerkleRoot defines a merkle root hash. In the Cosmos SDK, the AppHash of a
    block header becomes the root.
    """

    hash: bytes = betterproto.bytes_field(1)


@dataclass
class MerklePrefix(betterproto.Message):
    """
    MerklePrefix is merkle path prefixed to the key. The constructed key from
    the Path and the key will be append(Path.KeyPath, append(Path.KeyPrefix,
    key...))
    """

    key_prefix: bytes = betterproto.bytes_field(1)


@dataclass
class MerklePath(betterproto.Message):
    """
    MerklePath is the path used to verify commitment proofs, which can be an
    arbitrary structured object (defined by a commitment type).
    """

    key_path: "KeyPath" = betterproto.message_field(1)


@dataclass
class MerkleProof(betterproto.Message):
    """
    MerkleProof is a wrapper type that contains a merkle proof. It demonstrates
    membership or non-membership for an element or set of elements, verifiable
    in conjunction with a known commitment root. Proofs should be succinct.
    """

    proof: crypto.ProofOps = betterproto.message_field(1)


@dataclass
class KeyPath(betterproto.Message):
    """KeyPath defines a slice of keys"""

    keys: List["Key"] = betterproto.message_field(1)


@dataclass
class Key(betterproto.Message):
    """Key defines a proof Key"""

    name: bytes = betterproto.bytes_field(1)
    enc: "KeyEncoding" = betterproto.enum_field(2)
