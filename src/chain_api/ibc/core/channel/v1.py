# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ibc/core/channel/v1/channel.proto, ibc/core/channel/v1/query.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base.query import v1beta1
from .google import protobuf
from .ibc.core.client import v1


class State(betterproto.Enum):
    """
    State defines if a channel is in one of the following states: CLOSED, INIT,
    TRYOPEN, OPEN or UNINITIALIZED.
    """

    # Default State
    STATE_UNINITIALIZED_UNSPECIFIED = 0
    # A channel has just started the opening handshake.
    STATE_INIT = 1
    # A channel has acknowledged the handshake step on the counterparty chain.
    STATE_TRYOPEN = 2
    # A channel has completed the handshake. Open channels are ready to send and
    # receive packets.
    STATE_OPEN = 3
    # A channel has been closed and can no longer be used to send or receive
    # packets.
    STATE_CLOSED = 4


class Order(betterproto.Enum):
    """Order defines if a channel is ORDERED or UNORDERED"""

    # zero-value for channel ordering
    ORDER_NONE_UNSPECIFIED = 0
    # packets can be delivered in any order, which may differ from the order in
    # which they were sent.
    ORDER_UNORDERED = 1
    # packets are delivered exactly in the order which they were sent
    ORDER_ORDERED = 2


@dataclass
class MsgChannelOpenInit(betterproto.Message):
    """
    MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake. It
    is called by a relayer on Chain A.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    channel: "Channel" = betterproto.message_field(3)
    signer: str = betterproto.string_field(4)


@dataclass
class MsgChannelOpenTry(betterproto.Message):
    """
    MsgChannelOpenInit  defines a msg sent by a Relayer to try to open a
    channel on Chain B.
    """

    port_id: str = betterproto.string_field(1)
    desired_channel_id: str = betterproto.string_field(2)
    counterparty_chosen_channel_id: str = betterproto.string_field(3)
    channel: "Channel" = betterproto.message_field(4)
    counterparty_version: str = betterproto.string_field(5)
    proof_init: bytes = betterproto.bytes_field(6)
    proof_height: v1.Height = betterproto.message_field(7)
    signer: str = betterproto.string_field(8)


@dataclass
class MsgChannelOpenAck(betterproto.Message):
    """
    MsgChannelOpenAck defines a msg sent by a Relayer to Chain A to acknowledge
    the change of channel state to TRYOPEN on Chain B.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    counterparty_channel_id: str = betterproto.string_field(3)
    counterparty_version: str = betterproto.string_field(4)
    proof_try: bytes = betterproto.bytes_field(5)
    proof_height: v1.Height = betterproto.message_field(6)
    signer: str = betterproto.string_field(7)


@dataclass
class MsgChannelOpenConfirm(betterproto.Message):
    """
    MsgChannelOpenConfirm defines a msg sent by a Relayer to Chain B to
    acknowledge the change of channel state to OPEN on Chain A.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    proof_ack: bytes = betterproto.bytes_field(3)
    proof_height: v1.Height = betterproto.message_field(4)
    signer: str = betterproto.string_field(5)


@dataclass
class MsgChannelCloseInit(betterproto.Message):
    """
    MsgChannelCloseInit defines a msg sent by a Relayer to Chain A to close a
    channel with Chain B.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    signer: str = betterproto.string_field(3)


@dataclass
class MsgChannelCloseConfirm(betterproto.Message):
    """
    MsgChannelCloseConfirm defines a msg sent by a Relayer to Chain B to
    acknowledge the change of channel state to CLOSED on Chain A.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    proof_init: bytes = betterproto.bytes_field(3)
    proof_height: v1.Height = betterproto.message_field(4)
    signer: str = betterproto.string_field(5)


@dataclass
class MsgRecvPacket(betterproto.Message):
    """MsgRecvPacket receives incoming IBC packet"""

    packet: "Packet" = betterproto.message_field(1)
    proof: bytes = betterproto.bytes_field(2)
    proof_height: v1.Height = betterproto.message_field(3)
    signer: str = betterproto.string_field(4)


@dataclass
class MsgTimeout(betterproto.Message):
    """MsgTimeout receives timed-out packet"""

    packet: "Packet" = betterproto.message_field(1)
    proof: bytes = betterproto.bytes_field(2)
    proof_height: v1.Height = betterproto.message_field(3)
    next_sequence_recv: int = betterproto.uint64_field(4)
    signer: str = betterproto.string_field(5)


@dataclass
class MsgTimeoutOnClose(betterproto.Message):
    """
    MsgTimeoutOnClose timed-out packet upon counterparty channel closure.
    """

    packet: "Packet" = betterproto.message_field(1)
    proof: bytes = betterproto.bytes_field(2)
    proof_close: bytes = betterproto.bytes_field(3)
    proof_height: v1.Height = betterproto.message_field(4)
    next_sequence_recv: int = betterproto.uint64_field(5)
    signer: str = betterproto.string_field(6)


@dataclass
class MsgAcknowledgement(betterproto.Message):
    """MsgAcknowledgement receives incoming IBC acknowledgement"""

    packet: "Packet" = betterproto.message_field(1)
    acknowledgement: bytes = betterproto.bytes_field(2)
    proof: bytes = betterproto.bytes_field(3)
    proof_height: v1.Height = betterproto.message_field(4)
    signer: str = betterproto.string_field(5)


@dataclass
class Channel(betterproto.Message):
    """
    Channel defines pipeline for exactly-once packet delivery between specific
    modules on separate blockchains, which has at least one end capable of
    sending packets and one end capable of receiving packets.
    """

    # current state of the channel end
    state: "State" = betterproto.enum_field(1)
    # whether the channel is ordered or unordered
    ordering: "Order" = betterproto.enum_field(2)
    # counterparty channel end
    counterparty: "Counterparty" = betterproto.message_field(3)
    # list of connection identifiers, in order, along which packets sent on this
    # channel will travel
    connection_hops: List[str] = betterproto.string_field(4)
    # opaque channel version, which is agreed upon during the handshake
    version: str = betterproto.string_field(5)


@dataclass
class IdentifiedChannel(betterproto.Message):
    """
    IdentifiedChannel defines a channel with additional port and channel
    identifier fields.
    """

    # current state of the channel end
    state: "State" = betterproto.enum_field(1)
    # whether the channel is ordered or unordered
    ordering: "Order" = betterproto.enum_field(2)
    # counterparty channel end
    counterparty: "Counterparty" = betterproto.message_field(3)
    # list of connection identifiers, in order, along which packets sent on this
    # channel will travel
    connection_hops: List[str] = betterproto.string_field(4)
    # opaque channel version, which is agreed upon during the handshake
    version: str = betterproto.string_field(5)
    # port identifier
    port_id: str = betterproto.string_field(6)
    # channel identifier
    channel_id: str = betterproto.string_field(7)


@dataclass
class Counterparty(betterproto.Message):
    """Counterparty defines a channel end counterparty"""

    # port on the counterparty chain which owns the other end of the channel.
    port_id: str = betterproto.string_field(1)
    # channel end on the counterparty chain
    channel_id: str = betterproto.string_field(2)


@dataclass
class Packet(betterproto.Message):
    """
    Packet defines a type that carries data across different chains through IBC
    """

    # number corresponds to the order of sends and receives, where a Packet with
    # an earlier sequence number must be sent and received before a Packet with a
    # later sequence number.
    sequence: int = betterproto.uint64_field(1)
    # identifies the port on the sending chain.
    source_port: str = betterproto.string_field(2)
    # identifies the channel end on the sending chain.
    source_channel: str = betterproto.string_field(3)
    # identifies the port on the receiving chain.
    destination_port: str = betterproto.string_field(4)
    # identifies the channel end on the receiving chain.
    destination_channel: str = betterproto.string_field(5)
    # actual opaque bytes transferred directly to the application module
    data: bytes = betterproto.bytes_field(6)
    # block height after which the packet times out
    timeout_height: v1.Height = betterproto.message_field(7)
    # block timestamp (in nanoseconds) after which the packet times out
    timeout_timestamp: int = betterproto.uint64_field(8)


@dataclass
class PacketAckCommitment(betterproto.Message):
    """
    PacketAckCommitment defines the genesis type necessary to retrieve and
    store acknowlegements.
    """

    # channel port identifier.
    port_id: str = betterproto.string_field(1)
    # channel unique identifier.
    channel_id: str = betterproto.string_field(2)
    # packet sequence.
    sequence: int = betterproto.uint64_field(3)
    # packet commitment hash.
    hash: bytes = betterproto.bytes_field(4)


@dataclass
class Acknowledgement(betterproto.Message):
    """
    Acknowledgement is the recommended acknowledgement format to be used by
    app-specific protocols. NOTE: The field numbers 21 and 22 were explicitly
    chosen to avoid accidental conflicts with other protobuf message formats
    used for acknowledgements. The first byte of any message with this format
    will be the non-ASCII values `0xaa` (result) or `0xb2` (error). Implemented
    as defined by ICS:
    https://github.com/cosmos/ics/tree/master/spec/ics-004-channel-and-packet-
    semantics#acknowledgement-envelope
    """

    result: bytes = betterproto.bytes_field(21, group="response")
    error: str = betterproto.string_field(22, group="response")


@dataclass
class QueryChannelRequest(betterproto.Message):
    """
    QueryChannelRequest is the request type for the Query/Channel RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryChannelResponse(betterproto.Message):
    """
    QueryChannelResponse is the response type for the Query/Channel RPC method.
    Besides the Channel end, it includes a proof and the height from which the
    proof was retrieved.
    """

    # channel associated with the request identifiers
    channel: "Channel" = betterproto.message_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # merkle proof path
    proof_path: str = betterproto.string_field(3)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(4)


@dataclass
class QueryChannelsRequest(betterproto.Message):
    """
    QueryChannelsRequest is the request type for the Query/Channels RPC method
    """

    # pagination request
    pagination: v1beta1.PageRequest = betterproto.message_field(1)


@dataclass
class QueryChannelsResponse(betterproto.Message):
    """
    QueryChannelsResponse is the response type for the Query/Channels RPC
    method.
    """

    # list of stored channels of the chain.
    channels: List["IdentifiedChannel"] = betterproto.message_field(1)
    # pagination response
    pagination: v1beta1.PageResponse = betterproto.message_field(2)
    # query block height
    height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryConnectionChannelsRequest(betterproto.Message):
    """
    QueryConnectionChannelsRequest is the request type for the
    Query/QueryConnectionChannels RPC method
    """

    # connection unique identifier
    connection: str = betterproto.string_field(1)
    # pagination request
    pagination: v1beta1.PageRequest = betterproto.message_field(2)


@dataclass
class QueryConnectionChannelsResponse(betterproto.Message):
    """
    QueryConnectionChannelsResponse is the Response type for the
    Query/QueryConnectionChannels RPC method
    """

    # list of channels associated with a connection.
    channels: List["IdentifiedChannel"] = betterproto.message_field(1)
    # pagination response
    pagination: v1beta1.PageResponse = betterproto.message_field(2)
    # query block height
    height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryChannelClientStateRequest(betterproto.Message):
    """
    QueryChannelClientStateRequest is the request type for the
    Query/ClientState RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryChannelClientStateResponse(betterproto.Message):
    """
    QueryChannelClientStateResponse is the Response type for the
    Query/QueryChannelClientState RPC method
    """

    # client state associated with the channel
    identified_client_state: v1.IdentifiedClientState = betterproto.message_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # merkle proof path
    proof_path: str = betterproto.string_field(3)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(4)


@dataclass
class QueryChannelConsensusStateRequest(betterproto.Message):
    """
    QueryChannelConsensusStateRequest is the request type for the
    Query/ConsensusState RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # version number of the consensus state
    version_number: int = betterproto.uint64_field(3)
    # version height of the consensus state
    version_height: int = betterproto.uint64_field(4)


@dataclass
class QueryChannelConsensusStateResponse(betterproto.Message):
    """
    QueryChannelClientStateResponse is the Response type for the
    Query/QueryChannelClientState RPC method
    """

    # consensus state associated with the channel
    consensus_state: protobuf.Any = betterproto.message_field(1)
    # client ID associated with the consensus state
    client_id: str = betterproto.string_field(2)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(3)
    # merkle proof path
    proof_path: str = betterproto.string_field(4)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(5)


@dataclass
class QueryPacketCommitmentRequest(betterproto.Message):
    """
    QueryPacketCommitmentRequest is the request type for the
    Query/PacketCommitment RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # packet sequence
    sequence: int = betterproto.uint64_field(3)


@dataclass
class QueryPacketCommitmentResponse(betterproto.Message):
    """
    QueryPacketCommitmentResponse defines the client query response for a
    packet which also includes a proof, its path and the height form which the
    proof was retrieved
    """

    # packet associated with the request fields
    commitment: bytes = betterproto.bytes_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # merkle proof path
    proof_path: str = betterproto.string_field(3)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(4)


@dataclass
class QueryPacketCommitmentsRequest(betterproto.Message):
    """
    QueryPacketCommitmentsRequest is the request type for the
    Query/QueryPacketCommitments RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # pagination request
    pagination: v1beta1.PageRequest = betterproto.message_field(3)


@dataclass
class QueryPacketCommitmentsResponse(betterproto.Message):
    """
    QueryPacketCommitmentsResponse is the request type for the
    Query/QueryPacketCommitments RPC method
    """

    commitments: List["PacketAckCommitment"] = betterproto.message_field(1)
    # pagination response
    pagination: v1beta1.PageResponse = betterproto.message_field(2)
    # query block height
    height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryPacketAcknowledgementRequest(betterproto.Message):
    """
    QueryPacketAcknowledgementRequest is the request type for the
    Query/PacketAcknowledgement RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # packet sequence
    sequence: int = betterproto.uint64_field(3)


@dataclass
class QueryPacketAcknowledgementResponse(betterproto.Message):
    """
    QueryPacketAcknowledgementResponse defines the client query response for a
    packet which also includes a proof, its path and the height form which the
    proof was retrieved
    """

    # packet associated with the request fields
    acknowledgement: bytes = betterproto.bytes_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # merkle proof path
    proof_path: str = betterproto.string_field(3)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(4)


@dataclass
class QueryUnreceivedPacketsRequest(betterproto.Message):
    """
    QueryUnreceivedPacketsRequest is the request type for the
    Query/UnreceivedPackets RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # list of packet sequences
    packet_commitment_sequences: List[int] = betterproto.uint64_field(3)


@dataclass
class QueryUnreceivedPacketsResponse(betterproto.Message):
    """
    QueryUnreceivedPacketsResponse is the response type for the
    Query/UnreceivedPacketCommitments RPC method
    """

    # list of unreceived packet sequences
    sequences: List[int] = betterproto.uint64_field(1)
    # query block height
    height: v1.Height = betterproto.message_field(2)


@dataclass
class QueryUnrelayedAcksRequest(betterproto.Message):
    """
    QueryUnrelayedAcksRequest is the request type for the Query/UnrelayedAcks
    RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # list of commitment sequences
    packet_commitment_sequences: List[int] = betterproto.uint64_field(3)


@dataclass
class QueryUnrelayedAcksResponse(betterproto.Message):
    """
    QueryUnrelayedAcksResponse is the response type for the Query/UnrelayedAcks
    RPC method
    """

    # list of unrelayed acknowledgement sequences
    sequences: List[int] = betterproto.uint64_field(1)
    # query block height
    height: v1.Height = betterproto.message_field(2)


@dataclass
class QueryNextSequenceReceiveRequest(betterproto.Message):
    """
    QueryNextSequenceReceiveRequest is the request type for the
    Query/QueryNextSequenceReceiveRequest RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryNextSequenceReceiveResponse(betterproto.Message):
    """
    QuerySequenceResponse is the request type for the
    Query/QueryNextSequenceReceiveResponse RPC method
    """

    # next sequence receive number
    next_sequence_receive: int = betterproto.uint64_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # merkle proof path
    proof_path: str = betterproto.string_field(3)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(4)


class QueryStub(betterproto.ServiceStub):
    """Query provides defines the gRPC querier service"""

    async def channel(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryChannelResponse:
        """Channel queries an IBC Channel."""

        request = QueryChannelRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/Channel",
            request,
            QueryChannelResponse,
        )

    async def channels(
        self, *, pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryChannelsResponse:
        """Channels queries all the IBC channels of a chain."""

        request = QueryChannelsRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/Channels",
            request,
            QueryChannelsResponse,
        )

    async def connection_channels(
        self, *, connection: str = "", pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryConnectionChannelsResponse:
        """
        ConnectionChannels queries all the channels associated with a
        connection end.
        """

        request = QueryConnectionChannelsRequest()
        request.connection = connection
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/ConnectionChannels",
            request,
            QueryConnectionChannelsResponse,
        )

    async def channel_client_state(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryChannelClientStateResponse:
        """
        ChannelClientState queries for the client state for the channel
        associated with the provided channel identifiers.
        """

        request = QueryChannelClientStateRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/ChannelClientState",
            request,
            QueryChannelClientStateResponse,
        )

    async def channel_consensus_state(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        version_number: int = 0,
        version_height: int = 0,
    ) -> QueryChannelConsensusStateResponse:
        """
        ChannelConsensusState queries for the consensus state for the channel
        associated with the provided channel identifiers.
        """

        request = QueryChannelConsensusStateRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.version_number = version_number
        request.version_height = version_height

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/ChannelConsensusState",
            request,
            QueryChannelConsensusStateResponse,
        )

    async def packet_commitment(
        self, *, port_id: str = "", channel_id: str = "", sequence: int = 0
    ) -> QueryPacketCommitmentResponse:
        """PacketCommitment queries a stored packet commitment hash."""

        request = QueryPacketCommitmentRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.sequence = sequence

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/PacketCommitment",
            request,
            QueryPacketCommitmentResponse,
        )

    async def packet_commitments(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        pagination: Optional[v1beta1.PageRequest] = None,
    ) -> QueryPacketCommitmentsResponse:
        """
        PacketCommitments returns the all the packet commitments hashes
        associated with a channel.
        """

        request = QueryPacketCommitmentsRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/PacketCommitments",
            request,
            QueryPacketCommitmentsResponse,
        )

    async def packet_acknowledgement(
        self, *, port_id: str = "", channel_id: str = "", sequence: int = 0
    ) -> QueryPacketAcknowledgementResponse:
        """
        PacketAcknowledgement queries a stored packet acknowledgement hash.
        """

        request = QueryPacketAcknowledgementRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.sequence = sequence

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/PacketAcknowledgement",
            request,
            QueryPacketAcknowledgementResponse,
        )

    async def unreceived_packets(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        packet_commitment_sequences: List[int] = [],
    ) -> QueryUnreceivedPacketsResponse:
        """
        UnreceivedPackets returns all the unrelayed IBC packets associated with
        a channel and sequences.
        """

        request = QueryUnreceivedPacketsRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.packet_commitment_sequences = packet_commitment_sequences

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/UnreceivedPackets",
            request,
            QueryUnreceivedPacketsResponse,
        )

    async def unrelayed_acks(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        packet_commitment_sequences: List[int] = [],
    ) -> QueryUnrelayedAcksResponse:
        """
        UnrelayedAcks returns all the unrelayed IBC acknowledgements associated
        with a channel and sequences.
        """

        request = QueryUnrelayedAcksRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.packet_commitment_sequences = packet_commitment_sequences

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/UnrelayedAcks",
            request,
            QueryUnrelayedAcksResponse,
        )

    async def next_sequence_receive(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryNextSequenceReceiveResponse:
        """
        NextSequenceReceive returns the next receive sequence for a given
        channel.
        """

        request = QueryNextSequenceReceiveRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/NextSequenceReceive",
            request,
            QueryNextSequenceReceiveResponse,
        )
