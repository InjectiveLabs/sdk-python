# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: tendermint/abci/types.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional

import betterproto
import grpclib

from .tendermint import crypto
from .tendermint import types


class CheckTxType(betterproto.Enum):
    NEW = 0
    RECHECK = 1


class EvidenceType(betterproto.Enum):
    UNKNOWN = 0
    DUPLICATE_VOTE = 1
    LIGHT_CLIENT_ATTACK = 2


class ResponseOfferSnapshotResult(betterproto.Enum):
    UNKNOWN = 0
    ACCEPT = 1
    ABORT = 2
    REJECT = 3
    REJECT_FORMAT = 4
    REJECT_SENDER = 5


class ResponseApplySnapshotChunkResult(betterproto.Enum):
    UNKNOWN = 0
    ACCEPT = 1
    ABORT = 2
    RETRY = 3
    RETRY_SNAPSHOT = 4
    REJECT_SNAPSHOT = 5


@dataclass
class Request(betterproto.Message):
    echo: "RequestEcho" = betterproto.message_field(1, group="value")
    flush: "RequestFlush" = betterproto.message_field(2, group="value")
    info: "RequestInfo" = betterproto.message_field(3, group="value")
    set_option: "RequestSetOption" = betterproto.message_field(4, group="value")
    init_chain: "RequestInitChain" = betterproto.message_field(5, group="value")
    query: "RequestQuery" = betterproto.message_field(6, group="value")
    begin_block: "RequestBeginBlock" = betterproto.message_field(7, group="value")
    check_tx: "RequestCheckTx" = betterproto.message_field(8, group="value")
    deliver_tx: "RequestDeliverTx" = betterproto.message_field(9, group="value")
    end_block: "RequestEndBlock" = betterproto.message_field(10, group="value")
    commit: "RequestCommit" = betterproto.message_field(11, group="value")
    list_snapshots: "RequestListSnapshots" = betterproto.message_field(
        12, group="value"
    )
    offer_snapshot: "RequestOfferSnapshot" = betterproto.message_field(
        13, group="value"
    )
    load_snapshot_chunk: "RequestLoadSnapshotChunk" = betterproto.message_field(
        14, group="value"
    )
    apply_snapshot_chunk: "RequestApplySnapshotChunk" = betterproto.message_field(
        15, group="value"
    )


@dataclass
class RequestEcho(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class RequestFlush(betterproto.Message):
    pass


@dataclass
class RequestInfo(betterproto.Message):
    version: str = betterproto.string_field(1)
    block_version: int = betterproto.uint64_field(2)
    p2p_version: int = betterproto.uint64_field(3)


@dataclass
class RequestSetOption(betterproto.Message):
    """nondeterministic"""

    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass
class RequestInitChain(betterproto.Message):
    time: datetime = betterproto.message_field(1)
    chain_id: str = betterproto.string_field(2)
    consensus_params: "ConsensusParams" = betterproto.message_field(3)
    validators: List["ValidatorUpdate"] = betterproto.message_field(4)
    app_state_bytes: bytes = betterproto.bytes_field(5)
    initial_height: int = betterproto.int64_field(6)


@dataclass
class RequestQuery(betterproto.Message):
    data: bytes = betterproto.bytes_field(1)
    path: str = betterproto.string_field(2)
    height: int = betterproto.int64_field(3)
    prove: bool = betterproto.bool_field(4)


@dataclass
class RequestBeginBlock(betterproto.Message):
    hash: bytes = betterproto.bytes_field(1)
    header: types.Header = betterproto.message_field(2)
    last_commit_info: "LastCommitInfo" = betterproto.message_field(3)
    byzantine_validators: List["Evidence"] = betterproto.message_field(4)


@dataclass
class RequestCheckTx(betterproto.Message):
    tx: bytes = betterproto.bytes_field(1)
    type: "CheckTxType" = betterproto.enum_field(2)


@dataclass
class RequestDeliverTx(betterproto.Message):
    tx: bytes = betterproto.bytes_field(1)


@dataclass
class RequestEndBlock(betterproto.Message):
    height: int = betterproto.int64_field(1)


@dataclass
class RequestCommit(betterproto.Message):
    pass


@dataclass
class RequestListSnapshots(betterproto.Message):
    """lists available snapshots"""

    pass


@dataclass
class RequestOfferSnapshot(betterproto.Message):
    """offers a snapshot to the application"""

    snapshot: "Snapshot" = betterproto.message_field(1)
    app_hash: bytes = betterproto.bytes_field(2)


@dataclass
class RequestLoadSnapshotChunk(betterproto.Message):
    """loads a snapshot chunk"""

    height: int = betterproto.uint64_field(1)
    format: int = betterproto.uint32_field(2)
    chunk: int = betterproto.uint32_field(3)


@dataclass
class RequestApplySnapshotChunk(betterproto.Message):
    """Applies a snapshot chunk"""

    index: int = betterproto.uint32_field(1)
    chunk: bytes = betterproto.bytes_field(2)
    sender: str = betterproto.string_field(3)


@dataclass
class Response(betterproto.Message):
    exception: "ResponseException" = betterproto.message_field(1, group="value")
    echo: "ResponseEcho" = betterproto.message_field(2, group="value")
    flush: "ResponseFlush" = betterproto.message_field(3, group="value")
    info: "ResponseInfo" = betterproto.message_field(4, group="value")
    set_option: "ResponseSetOption" = betterproto.message_field(5, group="value")
    init_chain: "ResponseInitChain" = betterproto.message_field(6, group="value")
    query: "ResponseQuery" = betterproto.message_field(7, group="value")
    begin_block: "ResponseBeginBlock" = betterproto.message_field(8, group="value")
    check_tx: "ResponseCheckTx" = betterproto.message_field(9, group="value")
    deliver_tx: "ResponseDeliverTx" = betterproto.message_field(10, group="value")
    end_block: "ResponseEndBlock" = betterproto.message_field(11, group="value")
    commit: "ResponseCommit" = betterproto.message_field(12, group="value")
    list_snapshots: "ResponseListSnapshots" = betterproto.message_field(
        13, group="value"
    )
    offer_snapshot: "ResponseOfferSnapshot" = betterproto.message_field(
        14, group="value"
    )
    load_snapshot_chunk: "ResponseLoadSnapshotChunk" = betterproto.message_field(
        15, group="value"
    )
    apply_snapshot_chunk: "ResponseApplySnapshotChunk" = betterproto.message_field(
        16, group="value"
    )


@dataclass
class ResponseException(betterproto.Message):
    """nondeterministic"""

    error: str = betterproto.string_field(1)


@dataclass
class ResponseEcho(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class ResponseFlush(betterproto.Message):
    pass


@dataclass
class ResponseInfo(betterproto.Message):
    data: str = betterproto.string_field(1)
    version: str = betterproto.string_field(2)
    app_version: int = betterproto.uint64_field(3)
    last_block_height: int = betterproto.int64_field(4)
    last_block_app_hash: bytes = betterproto.bytes_field(5)


@dataclass
class ResponseSetOption(betterproto.Message):
    """nondeterministic"""

    code: int = betterproto.uint32_field(1)
    # bytes data = 2;
    log: str = betterproto.string_field(3)
    info: str = betterproto.string_field(4)


@dataclass
class ResponseInitChain(betterproto.Message):
    consensus_params: "ConsensusParams" = betterproto.message_field(1)
    validators: List["ValidatorUpdate"] = betterproto.message_field(2)
    app_hash: bytes = betterproto.bytes_field(3)


@dataclass
class ResponseQuery(betterproto.Message):
    code: int = betterproto.uint32_field(1)
    # bytes data = 2; // use "value" instead.
    log: str = betterproto.string_field(3)
    info: str = betterproto.string_field(4)
    index: int = betterproto.int64_field(5)
    key: bytes = betterproto.bytes_field(6)
    value: bytes = betterproto.bytes_field(7)
    proof_ops: crypto.ProofOps = betterproto.message_field(8)
    height: int = betterproto.int64_field(9)
    codespace: str = betterproto.string_field(10)


@dataclass
class ResponseBeginBlock(betterproto.Message):
    events: List["Event"] = betterproto.message_field(1)


@dataclass
class ResponseCheckTx(betterproto.Message):
    code: int = betterproto.uint32_field(1)
    data: bytes = betterproto.bytes_field(2)
    log: str = betterproto.string_field(3)
    info: str = betterproto.string_field(4)
    gas_wanted: int = betterproto.int64_field(5)
    gas_used: int = betterproto.int64_field(6)
    events: List["Event"] = betterproto.message_field(7)
    codespace: str = betterproto.string_field(8)


@dataclass
class ResponseDeliverTx(betterproto.Message):
    code: int = betterproto.uint32_field(1)
    data: bytes = betterproto.bytes_field(2)
    log: str = betterproto.string_field(3)
    info: str = betterproto.string_field(4)
    gas_wanted: int = betterproto.int64_field(5)
    gas_used: int = betterproto.int64_field(6)
    events: List["Event"] = betterproto.message_field(7)
    codespace: str = betterproto.string_field(8)


@dataclass
class ResponseEndBlock(betterproto.Message):
    validator_updates: List["ValidatorUpdate"] = betterproto.message_field(1)
    consensus_param_updates: "ConsensusParams" = betterproto.message_field(2)
    events: List["Event"] = betterproto.message_field(3)


@dataclass
class ResponseCommit(betterproto.Message):
    # reserve 1
    data: bytes = betterproto.bytes_field(2)
    retain_height: int = betterproto.int64_field(3)


@dataclass
class ResponseListSnapshots(betterproto.Message):
    snapshots: List["Snapshot"] = betterproto.message_field(1)


@dataclass
class ResponseOfferSnapshot(betterproto.Message):
    result: "ResponseOfferSnapshotResult" = betterproto.enum_field(1)


@dataclass
class ResponseLoadSnapshotChunk(betterproto.Message):
    chunk: bytes = betterproto.bytes_field(1)


@dataclass
class ResponseApplySnapshotChunk(betterproto.Message):
    result: "ResponseApplySnapshotChunkResult" = betterproto.enum_field(1)
    refetch_chunks: List[int] = betterproto.uint32_field(2)
    reject_senders: List[str] = betterproto.string_field(3)


@dataclass
class ConsensusParams(betterproto.Message):
    """
    ConsensusParams contains all consensus-relevant parameters that can be
    adjusted by the abci app
    """

    block: "BlockParams" = betterproto.message_field(1)
    evidence: types.EvidenceParams = betterproto.message_field(2)
    validator: types.ValidatorParams = betterproto.message_field(3)
    version: types.VersionParams = betterproto.message_field(4)


@dataclass
class BlockParams(betterproto.Message):
    """BlockParams contains limits on the block size."""

    # Note: must be greater than 0
    max_bytes: int = betterproto.int64_field(1)
    # Note: must be greater or equal to -1
    max_gas: int = betterproto.int64_field(2)


@dataclass
class LastCommitInfo(betterproto.Message):
    round: int = betterproto.int32_field(1)
    votes: List["VoteInfo"] = betterproto.message_field(2)


@dataclass
class Event(betterproto.Message):
    """
    Event allows application developers to attach additional information to
    ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and
    ResponseDeliverTx. Later, transactions may be queried using these events.
    """

    type: str = betterproto.string_field(1)
    attributes: List["EventAttribute"] = betterproto.message_field(2)


@dataclass
class EventAttribute(betterproto.Message):
    """EventAttribute is a single key-value pair, associated with an event."""

    key: bytes = betterproto.bytes_field(1)
    value: bytes = betterproto.bytes_field(2)
    index: bool = betterproto.bool_field(3)


@dataclass
class TxResult(betterproto.Message):
    """
    TxResult contains results of executing the transaction. One usage is
    indexing transaction results.
    """

    height: int = betterproto.int64_field(1)
    index: int = betterproto.uint32_field(2)
    tx: bytes = betterproto.bytes_field(3)
    result: "ResponseDeliverTx" = betterproto.message_field(4)


@dataclass
class Validator(betterproto.Message):
    """Validator"""

    address: bytes = betterproto.bytes_field(1)
    # PubKey pub_key = 2 [(gogoproto.nullable)=false];
    power: int = betterproto.int64_field(3)


@dataclass
class ValidatorUpdate(betterproto.Message):
    """ValidatorUpdate"""

    pub_key: crypto.PublicKey = betterproto.message_field(1)
    power: int = betterproto.int64_field(2)


@dataclass
class VoteInfo(betterproto.Message):
    """VoteInfo"""

    validator: "Validator" = betterproto.message_field(1)
    signed_last_block: bool = betterproto.bool_field(2)


@dataclass
class Evidence(betterproto.Message):
    type: "EvidenceType" = betterproto.enum_field(1)
    # The offending validator
    validator: "Validator" = betterproto.message_field(2)
    # The height when the offense occurred
    height: int = betterproto.int64_field(3)
    # The corresponding time where the offense occurred
    time: datetime = betterproto.message_field(4)
    # Total voting power of the validator set in case the ABCI application does
    # not store historical validators.
    # https://github.com/tendermint/tendermint/issues/4581
    total_voting_power: int = betterproto.int64_field(5)


@dataclass
class Snapshot(betterproto.Message):
    height: int = betterproto.uint64_field(1)
    format: int = betterproto.uint32_field(2)
    chunks: int = betterproto.uint32_field(3)
    hash: bytes = betterproto.bytes_field(4)
    metadata: bytes = betterproto.bytes_field(5)


class ABCIApplicationStub(betterproto.ServiceStub):
    async def echo(self, *, message: str = "") -> ResponseEcho:
        request = RequestEcho()
        request.message = message

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/Echo",
            request,
            ResponseEcho,
        )

    async def flush(self) -> ResponseFlush:
        request = RequestFlush()

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/Flush",
            request,
            ResponseFlush,
        )

    async def info(
        self, *, version: str = "", block_version: int = 0, p2p_version: int = 0
    ) -> ResponseInfo:
        request = RequestInfo()
        request.version = version
        request.block_version = block_version
        request.p2p_version = p2p_version

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/Info",
            request,
            ResponseInfo,
        )

    async def set_option(self, *, key: str = "", value: str = "") -> ResponseSetOption:
        request = RequestSetOption()
        request.key = key
        request.value = value

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/SetOption",
            request,
            ResponseSetOption,
        )

    async def deliver_tx(self, *, tx: bytes = b"") -> ResponseDeliverTx:
        request = RequestDeliverTx()
        request.tx = tx

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/DeliverTx",
            request,
            ResponseDeliverTx,
        )

    async def check_tx(
        self, *, tx: bytes = b"", type: "CheckTxType" = 0
    ) -> ResponseCheckTx:
        request = RequestCheckTx()
        request.tx = tx
        request.type = type

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/CheckTx",
            request,
            ResponseCheckTx,
        )

    async def query(
        self, *, data: bytes = b"", path: str = "", height: int = 0, prove: bool = False
    ) -> ResponseQuery:
        request = RequestQuery()
        request.data = data
        request.path = path
        request.height = height
        request.prove = prove

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/Query",
            request,
            ResponseQuery,
        )

    async def commit(self) -> ResponseCommit:
        request = RequestCommit()

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/Commit",
            request,
            ResponseCommit,
        )

    async def init_chain(
        self,
        *,
        time: Optional[datetime] = None,
        chain_id: str = "",
        consensus_params: Optional["ConsensusParams"] = None,
        validators: List["ValidatorUpdate"] = [],
        app_state_bytes: bytes = b"",
        initial_height: int = 0,
    ) -> ResponseInitChain:
        request = RequestInitChain()
        if time is not None:
            request.time = time
        request.chain_id = chain_id
        if consensus_params is not None:
            request.consensus_params = consensus_params
        if validators is not None:
            request.validators = validators
        request.app_state_bytes = app_state_bytes
        request.initial_height = initial_height

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/InitChain",
            request,
            ResponseInitChain,
        )

    async def begin_block(
        self,
        *,
        hash: bytes = b"",
        header: Optional[types.Header] = None,
        last_commit_info: Optional["LastCommitInfo"] = None,
        byzantine_validators: List["Evidence"] = [],
    ) -> ResponseBeginBlock:
        request = RequestBeginBlock()
        request.hash = hash
        if header is not None:
            request.header = header
        if last_commit_info is not None:
            request.last_commit_info = last_commit_info
        if byzantine_validators is not None:
            request.byzantine_validators = byzantine_validators

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/BeginBlock",
            request,
            ResponseBeginBlock,
        )

    async def end_block(self, *, height: int = 0) -> ResponseEndBlock:
        request = RequestEndBlock()
        request.height = height

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/EndBlock",
            request,
            ResponseEndBlock,
        )

    async def list_snapshots(self) -> ResponseListSnapshots:
        request = RequestListSnapshots()

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/ListSnapshots",
            request,
            ResponseListSnapshots,
        )

    async def offer_snapshot(
        self, *, snapshot: Optional["Snapshot"] = None, app_hash: bytes = b""
    ) -> ResponseOfferSnapshot:
        request = RequestOfferSnapshot()
        if snapshot is not None:
            request.snapshot = snapshot
        request.app_hash = app_hash

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/OfferSnapshot",
            request,
            ResponseOfferSnapshot,
        )

    async def load_snapshot_chunk(
        self, *, height: int = 0, format: int = 0, chunk: int = 0
    ) -> ResponseLoadSnapshotChunk:
        request = RequestLoadSnapshotChunk()
        request.height = height
        request.format = format
        request.chunk = chunk

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/LoadSnapshotChunk",
            request,
            ResponseLoadSnapshotChunk,
        )

    async def apply_snapshot_chunk(
        self, *, index: int = 0, chunk: bytes = b"", sender: str = ""
    ) -> ResponseApplySnapshotChunk:
        request = RequestApplySnapshotChunk()
        request.index = index
        request.chunk = chunk
        request.sender = sender

        return await self._unary_unary(
            "/tendermint.abci.ABCIApplication/ApplySnapshotChunk",
            request,
            ResponseApplySnapshotChunk,
        )
